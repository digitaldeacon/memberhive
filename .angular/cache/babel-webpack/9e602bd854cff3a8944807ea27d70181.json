{"ast":null,"code":"import _slicedToArray from \"/Applications/MAMP/htdocs/memberhive/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _createClass from \"/Applications/MAMP/htdocs/memberhive/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _classCallCheck from \"/Applications/MAMP/htdocs/memberhive/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport * as i1 from '@ngrx/store';\nimport { createAction, props, isNgrxMockEnvironment, select, ACTIVE_RUNTIME_CHECKS, createFeatureSelector, createSelector } from '@ngrx/store';\nimport * as i0 from '@angular/core';\nimport { InjectionToken, isDevMode, NgModule, Inject } from '@angular/core';\nimport * as i2 from '@angular/router';\nimport { NavigationStart, RoutesRecognized, NavigationCancel, NavigationError, NavigationEnd } from '@angular/router';\nimport { withLatestFrom } from 'rxjs/operators';\n/**\n * An action dispatched when a router navigation request is fired.\n */\n\nvar ROUTER_REQUEST = '@ngrx/router-store/request';\nvar routerRequestAction = createAction(ROUTER_REQUEST, props());\n/**\n * An action dispatched when the router navigates.\n */\n\nvar ROUTER_NAVIGATION = '@ngrx/router-store/navigation';\nvar routerNavigationAction = createAction(ROUTER_NAVIGATION, props());\n/**\n * An action dispatched when the router cancels navigation.\n */\n\nvar ROUTER_CANCEL = '@ngrx/router-store/cancel';\nvar routerCancelAction = createAction(ROUTER_CANCEL, props());\n/**\n * An action dispatched when the router errors.\n */\n\nvar ROUTER_ERROR = '@ngrx/router-store/error';\nvar routerErrorAction = createAction(ROUTER_ERROR, props());\n/**\n * An action dispatched after navigation has ended and new route is active.\n */\n\nvar ROUTER_NAVIGATED = '@ngrx/router-store/navigated';\nvar routerNavigatedAction = createAction(ROUTER_NAVIGATED, props());\n\nfunction routerReducer(state, action) {\n  // Allow compilation with strictFunctionTypes - ref: #1344\n  var routerAction = action;\n\n  switch (routerAction.type) {\n    case ROUTER_NAVIGATION:\n    case ROUTER_ERROR:\n    case ROUTER_CANCEL:\n      return {\n        state: routerAction.payload.routerState,\n        navigationId: routerAction.payload.event.id\n      };\n\n    default:\n      return state;\n  }\n}\n\nvar RouterStateSerializer = /*#__PURE__*/_createClass(function RouterStateSerializer() {\n  _classCallCheck(this, RouterStateSerializer);\n});\n\nvar DefaultRouterStateSerializer = /*#__PURE__*/function () {\n  function DefaultRouterStateSerializer() {\n    _classCallCheck(this, DefaultRouterStateSerializer);\n  }\n\n  _createClass(DefaultRouterStateSerializer, [{\n    key: \"serialize\",\n    value: function serialize(routerState) {\n      return {\n        root: this.serializeRoute(routerState.root),\n        url: routerState.url\n      };\n    }\n  }, {\n    key: \"serializeRoute\",\n    value: function serializeRoute(route) {\n      var _this = this;\n\n      var children = route.children.map(function (c) {\n        return _this.serializeRoute(c);\n      });\n      return {\n        params: route.params,\n        paramMap: route.paramMap,\n        data: route.data,\n        url: route.url,\n        outlet: route.outlet,\n        routeConfig: route.routeConfig ? {\n          component: route.routeConfig.component,\n          path: route.routeConfig.path,\n          pathMatch: route.routeConfig.pathMatch,\n          redirectTo: route.routeConfig.redirectTo,\n          outlet: route.routeConfig.outlet\n        } : null,\n        queryParams: route.queryParams,\n        queryParamMap: route.queryParamMap,\n        fragment: route.fragment,\n        component: route.routeConfig ? route.routeConfig.component : undefined,\n        root: undefined,\n        parent: undefined,\n        firstChild: children[0],\n        pathFromRoot: undefined,\n        children: children\n      };\n    }\n  }]);\n\n  return DefaultRouterStateSerializer;\n}();\n\nvar MinimalRouterStateSerializer = /*#__PURE__*/function () {\n  function MinimalRouterStateSerializer() {\n    _classCallCheck(this, MinimalRouterStateSerializer);\n  }\n\n  _createClass(MinimalRouterStateSerializer, [{\n    key: \"serialize\",\n    value: function serialize(routerState) {\n      return {\n        root: this.serializeRoute(routerState.root),\n        url: routerState.url\n      };\n    }\n  }, {\n    key: \"serializeRoute\",\n    value: function serializeRoute(route) {\n      var _this2 = this;\n\n      var children = route.children.map(function (c) {\n        return _this2.serializeRoute(c);\n      });\n      return {\n        params: route.params,\n        data: route.data,\n        url: route.url,\n        outlet: route.outlet,\n        routeConfig: route.routeConfig ? {\n          path: route.routeConfig.path,\n          pathMatch: route.routeConfig.pathMatch,\n          redirectTo: route.routeConfig.redirectTo,\n          outlet: route.routeConfig.outlet\n        } : null,\n        queryParams: route.queryParams,\n        fragment: route.fragment,\n        firstChild: children[0],\n        children: children\n      };\n    }\n  }]);\n\n  return MinimalRouterStateSerializer;\n}();\n\nvar NavigationActionTiming = /*#__PURE__*/(function () {\n  (function (NavigationActionTiming) {\n    NavigationActionTiming[NavigationActionTiming[\"PreActivation\"] = 1] = \"PreActivation\";\n    NavigationActionTiming[NavigationActionTiming[\"PostActivation\"] = 2] = \"PostActivation\";\n  })(NavigationActionTiming || (NavigationActionTiming = {}));\n\n  return NavigationActionTiming;\n})();\n\nvar _ROUTER_CONFIG = new InjectionToken('@ngrx/router-store Internal Configuration');\n\nvar ROUTER_CONFIG = new InjectionToken('@ngrx/router-store Configuration');\nvar DEFAULT_ROUTER_FEATURENAME = 'router';\n\nfunction _createRouterConfig(config) {\n  return Object.assign({\n    stateKey: DEFAULT_ROUTER_FEATURENAME,\n    serializer: MinimalRouterStateSerializer,\n    navigationActionTiming: NavigationActionTiming.PreActivation\n  }, config);\n}\n\nvar RouterTrigger = /*#__PURE__*/(function () {\n  (function (RouterTrigger) {\n    RouterTrigger[RouterTrigger[\"NONE\"] = 1] = \"NONE\";\n    RouterTrigger[RouterTrigger[\"ROUTER\"] = 2] = \"ROUTER\";\n    RouterTrigger[RouterTrigger[\"STORE\"] = 3] = \"STORE\";\n  })(RouterTrigger || (RouterTrigger = {}));\n\n  return RouterTrigger;\n})();\n\n/**\n * Connects RouterModule with StoreModule.\n *\n * During the navigation, before any guards or resolvers run, the router will dispatch\n * a ROUTER_NAVIGATION action, which has the following signature:\n *\n * ```\n * export type RouterNavigationPayload = {\n *   routerState: SerializedRouterStateSnapshot,\n *   event: RoutesRecognized\n * }\n * ```\n *\n * Either a reducer or an effect can be invoked in response to this action.\n * If the invoked reducer throws, the navigation will be canceled.\n *\n * If navigation gets canceled because of a guard, a ROUTER_CANCEL action will be\n * dispatched. If navigation results in an error, a ROUTER_ERROR action will be dispatched.\n *\n * Both ROUTER_CANCEL and ROUTER_ERROR contain the store state before the navigation\n * which can be used to restore the consistency of the store.\n *\n * Usage:\n *\n * ```typescript\n * @NgModule({\n *   declarations: [AppCmp, SimpleCmp],\n *   imports: [\n *     BrowserModule,\n *     StoreModule.forRoot(mapOfReducers),\n *     RouterModule.forRoot([\n *       { path: '', component: SimpleCmp },\n *       { path: 'next', component: SimpleCmp }\n *     ]),\n *     StoreRouterConnectingModule.forRoot()\n *   ],\n *   bootstrap: [AppCmp]\n * })\n * export class AppModule {\n * }\n * ```\n */\nvar StoreRouterConnectingModule = /*#__PURE__*/(function () {\n  var StoreRouterConnectingModule = /*#__PURE__*/function () {\n    function StoreRouterConnectingModule(store, router, serializer, errorHandler, config, activeRuntimeChecks) {\n      _classCallCheck(this, StoreRouterConnectingModule);\n\n      this.store = store;\n      this.router = router;\n      this.serializer = serializer;\n      this.errorHandler = errorHandler;\n      this.config = config;\n      this.activeRuntimeChecks = activeRuntimeChecks;\n      this.lastEvent = null;\n      this.routerState = null;\n      this.trigger = RouterTrigger.NONE;\n      this.stateKey = this.config.stateKey;\n\n      if (!isNgrxMockEnvironment() && isDevMode() && ((activeRuntimeChecks === null || activeRuntimeChecks === void 0 ? void 0 : activeRuntimeChecks.strictActionSerializability) || (activeRuntimeChecks === null || activeRuntimeChecks === void 0 ? void 0 : activeRuntimeChecks.strictStateSerializability)) && this.serializer instanceof DefaultRouterStateSerializer) {\n        console.warn('@ngrx/router-store: The serializability runtime checks cannot be enabled ' + 'with the DefaultRouterStateSerializer. The default serializer ' + 'has an unserializable router state and actions that are not serializable. ' + 'To use the serializability runtime checks either use ' + 'the MinimalRouterStateSerializer or implement a custom router state serializer. ' + 'This also applies to Ivy with immutability runtime checks.');\n      }\n\n      this.setUpStoreStateListener();\n      this.setUpRouterEventsListener();\n    }\n\n    _createClass(StoreRouterConnectingModule, [{\n      key: \"setUpStoreStateListener\",\n      value: function setUpStoreStateListener() {\n        var _this3 = this;\n\n        this.store.pipe(select(this.stateKey), withLatestFrom(this.store)).subscribe(function (_ref) {\n          var _ref2 = _slicedToArray(_ref, 2),\n              routerStoreState = _ref2[0],\n              storeState = _ref2[1];\n\n          _this3.navigateIfNeeded(routerStoreState, storeState);\n        });\n      }\n    }, {\n      key: \"navigateIfNeeded\",\n      value: function navigateIfNeeded(routerStoreState, storeState) {\n        var _this4 = this;\n\n        if (!routerStoreState || !routerStoreState.state) {\n          return;\n        }\n\n        if (this.trigger === RouterTrigger.ROUTER) {\n          return;\n        }\n\n        if (this.lastEvent instanceof NavigationStart) {\n          return;\n        }\n\n        var url = routerStoreState.state.url;\n\n        if (!isSameUrl(this.router.url, url)) {\n          this.storeState = storeState;\n          this.trigger = RouterTrigger.STORE;\n          this.router.navigateByUrl(url).catch(function (error) {\n            _this4.errorHandler.handleError(error);\n          });\n        }\n      }\n    }, {\n      key: \"setUpRouterEventsListener\",\n      value: function setUpRouterEventsListener() {\n        var _this5 = this;\n\n        var dispatchNavLate = this.config.navigationActionTiming === NavigationActionTiming.PostActivation;\n        var routesRecognized;\n        this.router.events.pipe(withLatestFrom(this.store)).subscribe(function (_ref3) {\n          var _ref4 = _slicedToArray(_ref3, 2),\n              event = _ref4[0],\n              storeState = _ref4[1];\n\n          _this5.lastEvent = event;\n\n          if (event instanceof NavigationStart) {\n            _this5.routerState = _this5.serializer.serialize(_this5.router.routerState.snapshot);\n\n            if (_this5.trigger !== RouterTrigger.STORE) {\n              _this5.storeState = storeState;\n\n              _this5.dispatchRouterRequest(event);\n            }\n          } else if (event instanceof RoutesRecognized) {\n            routesRecognized = event;\n\n            if (!dispatchNavLate && _this5.trigger !== RouterTrigger.STORE) {\n              _this5.dispatchRouterNavigation(event);\n            }\n          } else if (event instanceof NavigationCancel) {\n            _this5.dispatchRouterCancel(event);\n\n            _this5.reset();\n          } else if (event instanceof NavigationError) {\n            _this5.dispatchRouterError(event);\n\n            _this5.reset();\n          } else if (event instanceof NavigationEnd) {\n            if (_this5.trigger !== RouterTrigger.STORE) {\n              if (dispatchNavLate) {\n                _this5.dispatchRouterNavigation(routesRecognized);\n              }\n\n              _this5.dispatchRouterNavigated(event);\n            }\n\n            _this5.reset();\n          }\n        });\n      }\n    }, {\n      key: \"dispatchRouterRequest\",\n      value: function dispatchRouterRequest(event) {\n        this.dispatchRouterAction(ROUTER_REQUEST, {\n          event: event\n        });\n      }\n    }, {\n      key: \"dispatchRouterNavigation\",\n      value: function dispatchRouterNavigation(lastRoutesRecognized) {\n        var nextRouterState = this.serializer.serialize(lastRoutesRecognized.state);\n        this.dispatchRouterAction(ROUTER_NAVIGATION, {\n          routerState: nextRouterState,\n          event: new RoutesRecognized(lastRoutesRecognized.id, lastRoutesRecognized.url, lastRoutesRecognized.urlAfterRedirects, nextRouterState)\n        });\n      }\n    }, {\n      key: \"dispatchRouterCancel\",\n      value: function dispatchRouterCancel(event) {\n        this.dispatchRouterAction(ROUTER_CANCEL, {\n          storeState: this.storeState,\n          event: event\n        });\n      }\n    }, {\n      key: \"dispatchRouterError\",\n      value: function dispatchRouterError(event) {\n        this.dispatchRouterAction(ROUTER_ERROR, {\n          storeState: this.storeState,\n          event: new NavigationError(event.id, event.url, \"\".concat(event))\n        });\n      }\n    }, {\n      key: \"dispatchRouterNavigated\",\n      value: function dispatchRouterNavigated(event) {\n        var routerState = this.serializer.serialize(this.router.routerState.snapshot);\n        this.dispatchRouterAction(ROUTER_NAVIGATED, {\n          event: event,\n          routerState: routerState\n        });\n      }\n    }, {\n      key: \"dispatchRouterAction\",\n      value: function dispatchRouterAction(type, payload) {\n        this.trigger = RouterTrigger.ROUTER;\n\n        try {\n          this.store.dispatch({\n            type: type,\n            payload: Object.assign(Object.assign({\n              routerState: this.routerState\n            }, payload), {\n              event: this.config.routerState === 0\n              /* Full */\n              ? payload.event : {\n                id: payload.event.id,\n                url: payload.event.url,\n                // safe, as it will just be `undefined` for non-NavigationEnd router events\n                urlAfterRedirects: payload.event.urlAfterRedirects\n              }\n            })\n          });\n        } finally {\n          this.trigger = RouterTrigger.NONE;\n        }\n      }\n    }, {\n      key: \"reset\",\n      value: function reset() {\n        this.trigger = RouterTrigger.NONE;\n        this.storeState = null;\n        this.routerState = null;\n      }\n    }], [{\n      key: \"forRoot\",\n      value: function forRoot() {\n        var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        return {\n          ngModule: StoreRouterConnectingModule,\n          providers: [{\n            provide: _ROUTER_CONFIG,\n            useValue: config\n          }, {\n            provide: ROUTER_CONFIG,\n            useFactory: _createRouterConfig,\n            deps: [_ROUTER_CONFIG]\n          }, {\n            provide: RouterStateSerializer,\n            useClass: config.serializer ? config.serializer : config.routerState === 0\n            /* Full */\n            ? DefaultRouterStateSerializer : MinimalRouterStateSerializer\n          }]\n        };\n      }\n    }]);\n\n    return StoreRouterConnectingModule;\n  }();\n\n  /** @nocollapse */\n\n  /** @nocollapse */\n  StoreRouterConnectingModule.ɵfac = function StoreRouterConnectingModule_Factory(t) {\n    return new (t || StoreRouterConnectingModule)(i0.ɵɵinject(i1.Store), i0.ɵɵinject(i2.Router), i0.ɵɵinject(RouterStateSerializer), i0.ɵɵinject(i0.ErrorHandler), i0.ɵɵinject(ROUTER_CONFIG), i0.ɵɵinject(ACTIVE_RUNTIME_CHECKS));\n  };\n  /** @nocollapse */\n\n  /** @nocollapse */\n\n\n  StoreRouterConnectingModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: StoreRouterConnectingModule\n  });\n  /** @nocollapse */\n\n  /** @nocollapse */\n\n  StoreRouterConnectingModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n  return StoreRouterConnectingModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Check if the URLs are matching. Accounts for the possibility of trailing \"/\" in url.\n */\n\n\nfunction isSameUrl(first, second) {\n  return stripTrailingSlash(first) === stripTrailingSlash(second);\n}\n\nfunction stripTrailingSlash(text) {\n  if ((text === null || text === void 0 ? void 0 : text.length) > 0 && text[text.length - 1] === '/') {\n    return text.substring(0, text.length - 1);\n  }\n\n  return text;\n}\n\nfunction createRouterSelector() {\n  return createFeatureSelector(DEFAULT_ROUTER_FEATURENAME);\n}\n\nfunction getSelectors() {\n  var selectState = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : createRouterSelector();\n  var selectRouterState = createSelector(selectState, function (router) {\n    return router && router.state;\n  });\n  var selectRootRoute = createSelector(selectRouterState, function (routerState) {\n    return routerState && routerState.root;\n  });\n  var selectCurrentRoute = createSelector(selectRootRoute, function (rootRoute) {\n    if (!rootRoute) {\n      return undefined;\n    }\n\n    var route = rootRoute;\n\n    while (route.firstChild) {\n      route = route.firstChild;\n    }\n\n    return route;\n  });\n  var selectFragment = createSelector(selectRootRoute, function (route) {\n    return route && route.fragment;\n  });\n  var selectQueryParams = createSelector(selectRootRoute, function (route) {\n    return route && route.queryParams;\n  });\n\n  var selectQueryParam = function selectQueryParam(param) {\n    return createSelector(selectQueryParams, function (params) {\n      return params && params[param];\n    });\n  };\n\n  var selectRouteParams = createSelector(selectCurrentRoute, function (route) {\n    return route && route.params;\n  });\n\n  var selectRouteParam = function selectRouteParam(param) {\n    return createSelector(selectRouteParams, function (params) {\n      return params && params[param];\n    });\n  };\n\n  var selectRouteData = createSelector(selectCurrentRoute, function (route) {\n    return route && route.data;\n  });\n  var selectUrl = createSelector(selectRouterState, function (routerState) {\n    return routerState && routerState.url;\n  });\n  return {\n    selectCurrentRoute: selectCurrentRoute,\n    selectFragment: selectFragment,\n    selectQueryParams: selectQueryParams,\n    selectQueryParam: selectQueryParam,\n    selectRouteParams: selectRouteParams,\n    selectRouteParam: selectRouteParam,\n    selectRouteData: selectRouteData,\n    selectUrl: selectUrl\n  };\n}\n/**\n * DO NOT EDIT\n *\n * This file is automatically generated at build\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { DEFAULT_ROUTER_FEATURENAME, DefaultRouterStateSerializer, MinimalRouterStateSerializer, NavigationActionTiming, ROUTER_CANCEL, ROUTER_CONFIG, ROUTER_ERROR, ROUTER_NAVIGATED, ROUTER_NAVIGATION, ROUTER_REQUEST, RouterStateSerializer, StoreRouterConnectingModule, createRouterSelector, getSelectors, routerCancelAction, routerErrorAction, routerNavigatedAction, routerNavigationAction, routerReducer, routerRequestAction };","map":null,"metadata":{},"sourceType":"module"}