{"ast":null,"code":"import _createForOfIteratorHelper from \"/Applications/MAMP/htdocs/memberhive/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _classCallCheck from \"/Applications/MAMP/htdocs/memberhive/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Applications/MAMP/htdocs/memberhive/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _slicedToArray from \"/Applications/MAMP/htdocs/memberhive/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _toConsumableArray from \"/Applications/MAMP/htdocs/memberhive/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _toArray from \"/Applications/MAMP/htdocs/memberhive/node_modules/@babel/runtime/helpers/esm/toArray.js\";\nimport * as i0 from '@angular/core';\nimport { Injectable, NgModule } from '@angular/core';\nimport * as i2 from '@ngrx/effects';\nimport { ofType } from '@ngrx/effects';\nimport { ROUTER_NAVIGATION } from '@ngrx/router-store';\nimport { isObservable, of } from 'rxjs';\nimport { map, concatMap, catchError, groupBy, mergeMap, switchMap, filter, withLatestFrom } from 'rxjs/operators';\nimport * as i1 from '@ngrx/store';\n\nfunction _pessimisticUpdate(opts) {\n  return function (source) {\n    return source.pipe(mapActionAndState(), concatMap(runWithErrorHandling(opts.run, opts.onError)));\n  };\n}\n\nfunction _optimisticUpdate(opts) {\n  return function (source) {\n    return source.pipe(mapActionAndState(), concatMap(runWithErrorHandling(opts.run, opts.undoAction)));\n  };\n}\n\nfunction _fetch(opts) {\n  return function (source) {\n    if (opts.id) {\n      var groupedFetches = source.pipe(mapActionAndState(), groupBy(function (_ref) {\n        var _ref2 = _toArray(_ref),\n            action = _ref2[0],\n            store = _ref2.slice(1);\n\n        return opts.id.apply(opts, [action].concat(_toConsumableArray(store)));\n      }));\n      return groupedFetches.pipe(mergeMap(function (pairs) {\n        return pairs.pipe(switchMap(runWithErrorHandling(opts.run, opts.onError)));\n      }));\n    }\n\n    return source.pipe(mapActionAndState(), concatMap(runWithErrorHandling(opts.run, opts.onError)));\n  };\n}\n\nfunction _navigation(component, opts) {\n  return function (source) {\n    var nav = source.pipe(mapActionAndState(), filter(function (_ref3) {\n      var _ref4 = _slicedToArray(_ref3, 1),\n          action = _ref4[0];\n\n      return isStateSnapshot(action);\n    }), map(function (_ref5) {\n      var _ref6 = _toArray(_ref5),\n          action = _ref6[0],\n          slices = _ref6.slice(1);\n\n      if (!isStateSnapshot(action)) {\n        // Because of the above filter we'll never get here,\n        // but this properly type narrows `action`\n        return;\n      }\n\n      return [findSnapshot(component, action.payload.routerState.root)].concat(_toConsumableArray(slices));\n    }), filter(function (_ref7) {\n      var _ref8 = _slicedToArray(_ref7, 1),\n          snapshot = _ref8[0];\n\n      return !!snapshot;\n    }));\n    return nav.pipe(switchMap(runWithErrorHandling(opts.run, opts.onError)));\n  };\n}\n\nfunction isStateSnapshot(action) {\n  return action.type === ROUTER_NAVIGATION;\n}\n\nfunction runWithErrorHandling(run, onError) {\n  return function (_ref9) {\n    var _ref10 = _toArray(_ref9),\n        action = _ref10[0],\n        slices = _ref10.slice(1);\n\n    try {\n      var r = wrapIntoObservable(run.apply(void 0, [action].concat(_toConsumableArray(slices))));\n      return r.pipe(catchError(function (e) {\n        return wrapIntoObservable(onError(action, e));\n      }));\n    } catch (e) {\n      return wrapIntoObservable(onError(action, e));\n    }\n  };\n}\n/**\n * @whatItDoes maps Observable<Action | [Action, State]> to\n * Observable<[Action, State]>\n */\n\n\nfunction mapActionAndState() {\n  return function (source) {\n    return source.pipe(map(function (value) {\n      return normalizeActionAndState(value);\n    }));\n  };\n}\n/**\n * @whatItDoes Normalizes either a bare action or an array of action and slices\n * into an array of action and slices (or undefined)\n */\n\n\nfunction normalizeActionAndState(args) {\n  var action, slices;\n\n  if (args instanceof Array) {\n    var _args = _toArray(args);\n\n    action = _args[0];\n    slices = _args.slice(1);\n  } else {\n    slices = [];\n    action = args;\n  }\n\n  return [action].concat(_toConsumableArray(slices));\n}\n/**\n * @whatItDoes Provides convenience methods for implementing common operations of persisting data.\n */\n\n\nvar DataPersistence = /*#__PURE__*/(function () {\n  var DataPersistence = /*#__PURE__*/function () {\n    function DataPersistence(store, actions) {\n      _classCallCheck(this, DataPersistence);\n\n      this.store = store;\n      this.actions = actions;\n    }\n    /**\n     *\n     * @whatItDoes Handles pessimistic updates (updating the server first).\n     *\n     * Update the server implemented naively suffers from race conditions and poor error handling.\n     *\n     * `pessimisticUpdate` addresses these problems--it runs all fetches in order, which removes race conditions\n     * and forces the developer to handle errors.\n     *\n     * ## Example:\n     *\n     * ```typescript\n     * @Injectable()\n     * class TodoEffects {\n     *   @Effect() updateTodo = this.s.pessimisticUpdate<UpdateTodo>('UPDATE_TODO', {\n     *     // provides an action and the current state of the store\n     *     run(a, state) {\n     *       // update the backend first, and then dispatch an action that will\n     *       // update the client side\n     *       return this.backend(state.user, a.payload).map(updated => ({\n     *         type: 'TODO_UPDATED',\n     *         payload: updated\n     *       }));\n     *     },\n     *\n     *     onError(a, e: any) {\n     *       // we don't need to undo the changes on the client side.\n     *       // we can dispatch an error, or simply log the error here and return `null`\n     *       return null;\n     *     }\n     *   });\n     *\n     *   constructor(private s: DataPersistence<TodosState>, private backend: Backend) {}\n     * }\n     * ```\n     *\n     * Note that if you don't return a new action from the run callback, you must set the dispatch property\n     * of the effect to false, like this:\n     *\n     * ```\n     * class TodoEffects {\n     *   @Effect({dispatch: false})\n     *   updateTodo; //...\n     * }\n     * ```\n     */\n\n\n    _createClass(DataPersistence, [{\n      key: \"pessimisticUpdate\",\n      value: function pessimisticUpdate(actionType, opts) {\n        return this.actions.pipe(ofType(actionType), withLatestFrom(this.store), _pessimisticUpdate(opts));\n      }\n      /**\n       *\n       * @whatItDoes Handles optimistic updates (updating the client first).\n       *\n       * `optimisticUpdate` addresses these problems--it runs all fetches in order, which removes race conditions\n       * and forces the developer to handle errors.\n       *\n       * `optimisticUpdate` is different from `pessimisticUpdate`. In case of a failure, when using `optimisticUpdate`,\n       * the developer already updated the state locally, so the developer must provide an undo action.\n       *\n       * The error handling must be done in the callback, or by means of the undo action.\n       *\n       * ## Example:\n       *\n       * ```typescript\n       * @Injectable()\n       * class TodoEffects {\n       *   @Effect() updateTodo = this.s.optimisticUpdate<UpdateTodo>('UPDATE_TODO', {\n       *     // provides an action and the current state of the store\n       *     run: (a, state) => {\n       *       return this.backend(state.user, a.payload);\n       *     },\n       *\n       *     undoAction: (a, e: any) => {\n       *       // dispatch an undo action to undo the changes in the client state\n       *       return ({\n       *         type: 'UNDO_UPDATE_TODO',\n       *         payload: a\n       *       });\n       *     }\n       *   });\n       *\n       *   constructor(private s: DataPersistence<TodosState>, private backend: Backend) {}\n       * }\n       * ```\n       *\n       * Note that if you don't return a new action from the run callback, you must set the dispatch property\n       * of the effect to false, like this:\n       *\n       * ```\n       * class TodoEffects {\n       *   @Effect({dispatch: false})\n       *   updateTodo; //...\n       * }\n       * ```\n       */\n\n    }, {\n      key: \"optimisticUpdate\",\n      value: function optimisticUpdate(actionType, opts) {\n        return this.actions.pipe(ofType(actionType), withLatestFrom(this.store), _optimisticUpdate(opts));\n      }\n      /**\n       *\n       * @whatItDoes Handles data fetching.\n       *\n       * Data fetching implemented naively suffers from race conditions and poor error handling.\n       *\n       * `fetch` addresses these problems--it runs all fetches in order, which removes race conditions\n       * and forces the developer to handle errors.\n       *\n       * ## Example:\n       *\n       * ```typescript\n       * @Injectable()\n       * class TodoEffects {\n       *   @Effect() loadTodos = this.s.fetch<GetTodos>('GET_TODOS', {\n       *     // provides an action and the current state of the store\n       *     run: (a, state) => {\n       *       return this.backend(state.user, a.payload).map(r => ({\n       *         type: 'TODOS',\n       *         payload: r\n       *       });\n       *     },\n       *\n       *     onError: (a, e: any) => {\n       *       // dispatch an undo action to undo the changes in the client state\n       *     }\n       *   });\n       *\n       *   constructor(private s: DataPersistence<TodosState>, private backend: Backend) {}\n       * }\n       * ```\n       *\n       * This is correct, but because it set the concurrency to 1, it may not be performant.\n       *\n       * To fix that, you can provide the `id` function, like this:\n       *\n       * ```typescript\n       * @Injectable()\n       * class TodoEffects {\n       *   @Effect() loadTodo = this.s.fetch<GetTodo>('GET_TODO', {\n       *     id: (a, state) => {\n       *       return a.payload.id;\n       *     }\n       *\n       *     // provides an action and the current state of the store\n       *     run: (a, state) => {\n       *       return this.backend(state.user, a.payload).map(r => ({\n       *         type: 'TODO',\n       *         payload: r\n       *       });\n       *     },\n       *\n       *     onError: (a, e: any) => {\n       *       // dispatch an undo action to undo the changes in the client state\n       *       return null;\n       *     }\n       *   });\n       *\n       *   constructor(private s: DataPersistence<TodosState>, private backend: Backend) {}\n       * }\n       * ```\n       *\n       * With this setup, the requests for Todo 1 will run concurrently with the requests for Todo 2.\n       *\n       * In addition, if DataPersistence notices that there are multiple requests for Todo 1 scheduled,\n       * it will only run the last one.\n       */\n\n    }, {\n      key: \"fetch\",\n      value: function fetch(actionType, opts) {\n        return this.actions.pipe(ofType(actionType), withLatestFrom(this.store), _fetch(opts));\n      }\n      /**\n       * @whatItDoes Handles data fetching as part of router navigation.\n       *\n       * Data fetching implemented naively suffers from race conditions and poor error handling.\n       *\n       * `navigation` addresses these problems.\n       *\n       * It checks if an activated router state contains the passed in component type, and, if it does, runs the `run`\n       * callback. It provides the activated snapshot associated with the component and the current state. And it only runs\n       * the last request.\n       *\n       * ## Example:\n       *\n       * ```typescript\n       * @Injectable()\n       * class TodoEffects {\n       *   @Effect() loadTodo = this.s.navigation(TodoComponent, {\n       *     run: (a, state) => {\n       *       return this.backend.fetchTodo(a.params['id']).map(todo => ({\n       *         type: 'TODO_LOADED',\n       *         payload: todo\n       *       }));\n       *     },\n       *     onError: (a, e: any) => {\n       *       // we can log and error here and return null\n       *       // we can also navigate back\n       *       return null;\n       *     }\n       *   });\n       *   constructor(private s: DataPersistence<TodosState>, private backend: Backend) {}\n       * }\n       * ```\n       */\n\n    }, {\n      key: \"navigation\",\n      value: function navigation(component, opts) {\n        return this.actions.pipe(withLatestFrom(this.store), _navigation(component, opts));\n      }\n    }]);\n\n    return DataPersistence;\n  }();\n\n  DataPersistence.ɵfac = function DataPersistence_Factory(t) {\n    return new (t || DataPersistence)(i0.ɵɵinject(i1.Store), i0.ɵɵinject(i2.Actions));\n  };\n\n  DataPersistence.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: DataPersistence,\n    factory: DataPersistence.ɵfac\n  });\n  return DataPersistence;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nfunction findSnapshot(component, s) {\n  if (s.routeConfig && s.routeConfig.component === component) {\n    return s;\n  }\n\n  var _iterator = _createForOfIteratorHelper(s.children),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var c = _step.value;\n      var ss = findSnapshot(component, c);\n\n      if (ss) {\n        return ss;\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return null;\n}\n\nfunction wrapIntoObservable(obj) {\n  if (isObservable(obj)) {\n    return obj;\n  } else if (!obj) {\n    return of();\n  } else {\n    return of(obj);\n  }\n}\n/**\n * @whatItDoes Provides services for enterprise Angular applications.\n *\n * See {@link DataPersistence} for more information.\n */\n\n\nvar NxModule = /*#__PURE__*/(function () {\n  var NxModule = /*#__PURE__*/function () {\n    function NxModule() {\n      _classCallCheck(this, NxModule);\n    }\n\n    _createClass(NxModule, null, [{\n      key: \"forRoot\",\n      value: function forRoot() {\n        return {\n          ngModule: NxModule,\n          providers: [DataPersistence]\n        };\n      }\n    }]);\n\n    return NxModule;\n  }();\n\n  NxModule.ɵfac = function NxModule_Factory(t) {\n    return new (t || NxModule)();\n  };\n\n  NxModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: NxModule\n  });\n  NxModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n  return NxModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { DataPersistence, NxModule, _fetch as fetch, _navigation as navigation, _optimisticUpdate as optimisticUpdate, _pessimisticUpdate as pessimisticUpdate }; //# sourceMappingURL=nrwl-angular.mjs.map","map":null,"metadata":{},"sourceType":"module"}