{"ast":null,"code":"import _inherits from \"/Applications/MAMP/htdocs/memberhive/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Applications/MAMP/htdocs/memberhive/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport _slicedToArray from \"/Applications/MAMP/htdocs/memberhive/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _toConsumableArray from \"/Applications/MAMP/htdocs/memberhive/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _createForOfIteratorHelper from \"/Applications/MAMP/htdocs/memberhive/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _createClass from \"/Applications/MAMP/htdocs/memberhive/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _classCallCheck from \"/Applications/MAMP/htdocs/memberhive/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport * as i0 from '@angular/core';\nimport { APP_BOOTSTRAP_LISTENER, PLATFORM_ID, NgModule, Injectable, InjectionToken, Inject, inject, Directive } from '@angular/core';\nimport { isPlatformBrowser, DOCUMENT, isPlatformServer } from '@angular/common';\nimport { BehaviorSubject, Observable, merge, Subject, asapScheduler, of, fromEvent } from 'rxjs';\nimport { applyCssPrefixes, extendObject, buildLayoutCSS } from '@angular/flex-layout/_private-utils';\nimport { filter, tap, map, debounceTime, switchMap, takeUntil, take } from 'rxjs/operators';\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Find all of the server-generated stylings, if any, and remove them\n * This will be in the form of inline classes and the style block in the\n * head of the DOM\n */\n\nfunction removeStyles(_document, platformId) {\n  return function () {\n    if (isPlatformBrowser(platformId)) {\n      var elements = Array.from(_document.querySelectorAll(\"[class*=\".concat(CLASS_NAME, \"]\"))); // RegExp constructor should only be used if passing a variable to the constructor.\n      // When using static regular expression it is more performant to use reg exp literal.\n      // This is also needed to provide Safari 9 compatibility, please see\n      // https://stackoverflow.com/questions/37919802 for more discussion.\n\n      var classRegex = /\\bflex-layout-.+?\\b/g;\n      elements.forEach(function (el) {\n        el.classList.contains(\"\".concat(CLASS_NAME, \"ssr\")) && el.parentNode ? el.parentNode.removeChild(el) : el.className.replace(classRegex, '');\n      });\n    }\n  };\n}\n/**\n *  Provider to remove SSR styles on the browser\n */\n\n\nvar BROWSER_PROVIDER = {\n  provide: APP_BOOTSTRAP_LISTENER,\n  useFactory: removeStyles,\n  deps: [DOCUMENT, PLATFORM_ID],\n  multi: true\n};\nvar CLASS_NAME = 'flex-layout-';\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * *****************************************************************\n * Define module for common Angular Layout utilities\n * *****************************************************************\n */\n\nvar CoreModule = /*#__PURE__*/(function () {\n  var CoreModule = /*#__PURE__*/_createClass(function CoreModule() {\n    _classCallCheck(this, CoreModule);\n  });\n\n  CoreModule.ɵfac = function CoreModule_Factory(t) {\n    return new (t || CoreModule)();\n  };\n\n  CoreModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: CoreModule\n  });\n  CoreModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    providers: [BROWSER_PROVIDER]\n  });\n  return CoreModule;\n})();\n\n/*#__PURE__*/\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Class instances emitted [to observers] for each mql notification\n */\n\n\nvar MediaChange = /*#__PURE__*/function () {\n  /**\n   * @param matches whether the mediaQuery is currently activated\n   * @param mediaQuery e.g. (min-width: 600px) and (max-width: 959px)\n   * @param mqAlias e.g. gt-sm, md, gt-lg\n   * @param suffix e.g. GtSM, Md, GtLg\n   * @param priority the priority of activation for the given breakpoint\n   */\n  function MediaChange() {\n    var matches = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    var mediaQuery = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'all';\n    var mqAlias = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n    var suffix = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '';\n    var priority = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n\n    _classCallCheck(this, MediaChange);\n\n    this.matches = matches;\n    this.mediaQuery = mediaQuery;\n    this.mqAlias = mqAlias;\n    this.suffix = suffix;\n    this.priority = priority;\n    this.property = '';\n  }\n  /** Create an exact copy of the MediaChange */\n\n\n  _createClass(MediaChange, [{\n    key: \"clone\",\n    value: function clone() {\n      return new MediaChange(this.matches, this.mediaQuery, this.mqAlias, this.suffix);\n    }\n  }]);\n\n  return MediaChange;\n}();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Utility to emulate a CSS stylesheet\n *\n * This utility class stores all of the styles for a given HTML element\n * as a readonly `stylesheet` map.\n */\n\n\nvar StylesheetMap = /*#__PURE__*/(function () {\n  var StylesheetMap = /*#__PURE__*/function () {\n    function StylesheetMap() {\n      _classCallCheck(this, StylesheetMap);\n\n      this.stylesheet = new Map();\n    }\n    /**\n     * Add an individual style to an HTML element\n     */\n\n\n    _createClass(StylesheetMap, [{\n      key: \"addStyleToElement\",\n      value: function addStyleToElement(element, style, value) {\n        var stylesheet = this.stylesheet.get(element);\n\n        if (stylesheet) {\n          stylesheet.set(style, value);\n        } else {\n          this.stylesheet.set(element, new Map([[style, value]]));\n        }\n      }\n      /**\n       * Clear the virtual stylesheet\n       */\n\n    }, {\n      key: \"clearStyles\",\n      value: function clearStyles() {\n        this.stylesheet.clear();\n      }\n      /**\n       * Retrieve a given style for an HTML element\n       */\n\n    }, {\n      key: \"getStyleForElement\",\n      value: function getStyleForElement(el, styleName) {\n        var styles = this.stylesheet.get(el);\n        var value = '';\n\n        if (styles) {\n          var style = styles.get(styleName);\n\n          if (typeof style === 'number' || typeof style === 'string') {\n            value = style + '';\n          }\n        }\n\n        return value;\n      }\n    }]);\n\n    return StylesheetMap;\n  }();\n\n  StylesheetMap.ɵfac = function StylesheetMap_Factory(t) {\n    return new (t || StylesheetMap)();\n  };\n\n  StylesheetMap.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: StylesheetMap,\n    factory: StylesheetMap.ɵfac,\n    providedIn: 'root'\n  });\n  return StylesheetMap;\n})();\n\n/*#__PURE__*/\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nvar DEFAULT_CONFIG = {\n  addFlexToParent: true,\n  addOrientationBps: false,\n  disableDefaultBps: false,\n  disableVendorPrefixes: false,\n  serverLoaded: false,\n  useColumnBasisZero: true,\n  printWithBreakpoints: [],\n  mediaTriggerAutoRestore: true,\n  ssrObserveBreakpoints: []\n};\nvar LAYOUT_CONFIG = /*#__PURE__*/new InjectionToken('Flex Layout token, config options for the library', {\n  providedIn: 'root',\n  factory: function factory() {\n    return DEFAULT_CONFIG;\n  }\n});\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Token that is provided to tell whether the FlexLayoutServerModule\n * has been included in the bundle\n *\n * NOTE: This can be manually provided to disable styles when using SSR\n */\n\nvar SERVER_TOKEN = /*#__PURE__*/new InjectionToken('FlexLayoutServerLoaded', {\n  providedIn: 'root',\n  factory: function factory() {\n    return false;\n  }\n});\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nvar BREAKPOINT = /*#__PURE__*/new InjectionToken('Flex Layout token, collect all breakpoints into one provider', {\n  providedIn: 'root',\n  factory: function factory() {\n    return null;\n  }\n});\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * For the specified MediaChange, make sure it contains the breakpoint alias\n * and suffix (if available).\n */\n\nfunction mergeAlias(dest, source) {\n  dest = dest ? dest.clone() : new MediaChange();\n\n  if (source) {\n    dest.mqAlias = source.alias;\n    dest.mediaQuery = source.mediaQuery;\n    dest.suffix = source.suffix;\n    dest.priority = source.priority;\n  }\n\n  return dest;\n}\n/** A class that encapsulates CSS style generation for common directives */\n\n\nvar StyleBuilder = /*#__PURE__*/function () {\n  function StyleBuilder() {\n    _classCallCheck(this, StyleBuilder);\n\n    /** Whether to cache the generated output styles */\n    this.shouldCache = true;\n  }\n  /**\n   * Run a side effect computation given the input string and the computed styles\n   * from the build task and the host configuration object\n   * NOTE: This should be a no-op unless an algorithm is provided in a subclass\n   */\n\n\n  _createClass(StyleBuilder, [{\n    key: \"sideEffect\",\n    value: function sideEffect(_input, _styles, _parent) {}\n  }]);\n\n  return StyleBuilder;\n}();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nvar StyleUtils = /*#__PURE__*/(function () {\n  var StyleUtils = /*#__PURE__*/function () {\n    function StyleUtils(_serverStylesheet, _serverModuleLoaded, _platformId, layoutConfig) {\n      _classCallCheck(this, StyleUtils);\n\n      this._serverStylesheet = _serverStylesheet;\n      this._serverModuleLoaded = _serverModuleLoaded;\n      this._platformId = _platformId;\n      this.layoutConfig = layoutConfig;\n    }\n    /**\n     * Applies styles given via string pair or object map to the directive element\n     */\n\n\n    _createClass(StyleUtils, [{\n      key: \"applyStyleToElement\",\n      value: function applyStyleToElement(element, style) {\n        var value = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n        var styles = {};\n\n        if (typeof style === 'string') {\n          styles[style] = value;\n          style = styles;\n        }\n\n        styles = this.layoutConfig.disableVendorPrefixes ? style : applyCssPrefixes(style);\n\n        this._applyMultiValueStyleToElement(styles, element);\n      }\n      /**\n       * Applies styles given via string pair or object map to the directive's element\n       */\n\n    }, {\n      key: \"applyStyleToElements\",\n      value: function applyStyleToElements(style) {\n        var _this = this;\n\n        var elements = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n        var styles = this.layoutConfig.disableVendorPrefixes ? style : applyCssPrefixes(style);\n        elements.forEach(function (el) {\n          _this._applyMultiValueStyleToElement(styles, el);\n        });\n      }\n      /**\n       * Determine the DOM element's Flexbox flow (flex-direction)\n       *\n       * Check inline style first then check computed (stylesheet) style\n       */\n\n    }, {\n      key: \"getFlowDirection\",\n      value: function getFlowDirection(target) {\n        var query = 'flex-direction';\n        var value = this.lookupStyle(target, query);\n        var hasInlineValue = this.lookupInlineStyle(target, query) || isPlatformServer(this._platformId) && this._serverModuleLoaded ? value : '';\n        return [value || 'row', hasInlineValue];\n      }\n    }, {\n      key: \"hasWrap\",\n      value: function hasWrap(target) {\n        var query = 'flex-wrap';\n        return this.lookupStyle(target, query) === 'wrap';\n      }\n      /**\n       * Find the DOM element's raw attribute value (if any)\n       */\n\n    }, {\n      key: \"lookupAttributeValue\",\n      value: function lookupAttributeValue(element, attribute) {\n        return element.getAttribute(attribute) || '';\n      }\n      /**\n       * Find the DOM element's inline style value (if any)\n       */\n\n    }, {\n      key: \"lookupInlineStyle\",\n      value: function lookupInlineStyle(element, styleName) {\n        return isPlatformBrowser(this._platformId) ? element.style.getPropertyValue(styleName) : this._getServerStyle(element, styleName);\n      }\n      /**\n       * Determine the inline or inherited CSS style\n       * NOTE: platform-server has no implementation for getComputedStyle\n       */\n\n    }, {\n      key: \"lookupStyle\",\n      value: function lookupStyle(element, styleName) {\n        var inlineOnly = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n        var value = '';\n\n        if (element) {\n          var immediateValue = value = this.lookupInlineStyle(element, styleName);\n\n          if (!immediateValue) {\n            if (isPlatformBrowser(this._platformId)) {\n              if (!inlineOnly) {\n                value = getComputedStyle(element).getPropertyValue(styleName);\n              }\n            } else {\n              if (this._serverModuleLoaded) {\n                value = this._serverStylesheet.getStyleForElement(element, styleName);\n              }\n            }\n          }\n        } // Note: 'inline' is the default of all elements, unless UA stylesheet overrides;\n        //       in which case getComputedStyle() should determine a valid value.\n\n\n        return value ? value.trim() : '';\n      }\n      /**\n       * Applies the styles to the element. The styles object map may contain an array of values\n       * Each value will be added as element style\n       * Keys are sorted to add prefixed styles (like -webkit-x) first, before the standard ones\n       */\n\n    }, {\n      key: \"_applyMultiValueStyleToElement\",\n      value: function _applyMultiValueStyleToElement(styles, element) {\n        var _this2 = this;\n\n        Object.keys(styles).sort().forEach(function (key) {\n          var el = styles[key];\n          var values = Array.isArray(el) ? el : [el];\n          values.sort();\n\n          var _iterator = _createForOfIteratorHelper(values),\n              _step;\n\n          try {\n            for (_iterator.s(); !(_step = _iterator.n()).done;) {\n              var value = _step.value;\n              value = value ? value + '' : '';\n\n              if (isPlatformBrowser(_this2._platformId) || !_this2._serverModuleLoaded) {\n                isPlatformBrowser(_this2._platformId) ? element.style.setProperty(key, value) : _this2._setServerStyle(element, key, value);\n              } else {\n                _this2._serverStylesheet.addStyleToElement(element, key, value);\n              }\n            }\n          } catch (err) {\n            _iterator.e(err);\n          } finally {\n            _iterator.f();\n          }\n        });\n      }\n    }, {\n      key: \"_setServerStyle\",\n      value: function _setServerStyle(element, styleName, styleValue) {\n        styleName = styleName.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();\n\n        var styleMap = this._readStyleAttribute(element);\n\n        styleMap[styleName] = styleValue || '';\n\n        this._writeStyleAttribute(element, styleMap);\n      }\n    }, {\n      key: \"_getServerStyle\",\n      value: function _getServerStyle(element, styleName) {\n        var styleMap = this._readStyleAttribute(element);\n\n        return styleMap[styleName] || '';\n      }\n    }, {\n      key: \"_readStyleAttribute\",\n      value: function _readStyleAttribute(element) {\n        var styleMap = {};\n        var styleAttribute = element.getAttribute('style');\n\n        if (styleAttribute) {\n          var styleList = styleAttribute.split(/;+/g);\n\n          for (var i = 0; i < styleList.length; i++) {\n            var style = styleList[i].trim();\n\n            if (style.length > 0) {\n              var colonIndex = style.indexOf(':');\n\n              if (colonIndex === -1) {\n                throw new Error(\"Invalid CSS style: \".concat(style));\n              }\n\n              var name = style.substr(0, colonIndex).trim();\n              styleMap[name] = style.substr(colonIndex + 1).trim();\n            }\n          }\n        }\n\n        return styleMap;\n      }\n    }, {\n      key: \"_writeStyleAttribute\",\n      value: function _writeStyleAttribute(element, styleMap) {\n        var styleAttrValue = '';\n\n        for (var key in styleMap) {\n          var newValue = styleMap[key];\n\n          if (newValue) {\n            styleAttrValue += key + ':' + styleMap[key] + ';';\n          }\n        }\n\n        element.setAttribute('style', styleAttrValue);\n      }\n    }]);\n\n    return StyleUtils;\n  }();\n\n  StyleUtils.ɵfac = function StyleUtils_Factory(t) {\n    return new (t || StyleUtils)(i0.ɵɵinject(StylesheetMap), i0.ɵɵinject(SERVER_TOKEN), i0.ɵɵinject(PLATFORM_ID), i0.ɵɵinject(LAYOUT_CONFIG));\n  };\n\n  StyleUtils.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: StyleUtils,\n    factory: StyleUtils.ɵfac,\n    providedIn: 'root'\n  });\n  return StyleUtils;\n})();\n\n/*#__PURE__*/\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/** HOF to sort the breakpoints by descending priority */\n\n\nfunction sortDescendingPriority(a, b) {\n  var priorityA = a ? a.priority || 0 : 0;\n  var priorityB = b ? b.priority || 0 : 0;\n  return priorityB - priorityA;\n}\n/** HOF to sort the breakpoints by ascending priority */\n\n\nfunction sortAscendingPriority(a, b) {\n  var pA = a.priority || 0;\n  var pB = b.priority || 0;\n  return pA - pB;\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * MediaMonitor configures listeners to mediaQuery changes and publishes an Observable facade to\n * convert mediaQuery change callbacks to subscriber notifications. These notifications will be\n * performed within the ng Zone to trigger change detections and component updates.\n *\n * NOTE: both mediaQuery activations and de-activations are announced in notifications\n */\n\n\nvar MatchMedia = /*#__PURE__*/(function () {\n  var MatchMedia = /*#__PURE__*/function () {\n    function MatchMedia(_zone, _platformId, _document) {\n      _classCallCheck(this, MatchMedia);\n\n      this._zone = _zone;\n      this._platformId = _platformId;\n      this._document = _document;\n      /** Initialize source with 'all' so all non-responsive APIs trigger style updates */\n\n      this.source = new BehaviorSubject(new MediaChange(true));\n      this.registry = new Map();\n      this.pendingRemoveListenerFns = [];\n      this._observable$ = this.source.asObservable();\n    }\n    /**\n     * Publish list of all current activations\n     */\n\n\n    _createClass(MatchMedia, [{\n      key: \"activations\",\n      get: function get() {\n        var results = [];\n        this.registry.forEach(function (mql, key) {\n          if (mql.matches) {\n            results.push(key);\n          }\n        });\n        return results;\n      }\n      /**\n       * For the specified mediaQuery?\n       */\n\n    }, {\n      key: \"isActive\",\n      value: function isActive(mediaQuery) {\n        var mql = this.registry.get(mediaQuery);\n        return !!mql ? mql.matches : this.registerQuery(mediaQuery).some(function (m) {\n          return m.matches;\n        });\n      }\n      /**\n       * External observers can watch for all (or a specific) mql changes.\n       * Typically used by the MediaQueryAdaptor; optionally available to components\n       * who wish to use the MediaMonitor as mediaMonitor$ observable service.\n       *\n       * Use deferred registration process to register breakpoints only on subscription\n       * This logic also enforces logic to register all mediaQueries BEFORE notify\n       * subscribers of notifications.\n       */\n\n    }, {\n      key: \"observe\",\n      value: function observe(mqList) {\n        var _this3 = this;\n\n        var filterOthers = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n        if (mqList && mqList.length) {\n          var matchMedia$ = this._observable$.pipe(filter(function (change) {\n            return !filterOthers ? true : mqList.indexOf(change.mediaQuery) > -1;\n          }));\n\n          var registration$ = new Observable(function (observer) {\n            var matches = _this3.registerQuery(mqList);\n\n            if (matches.length) {\n              var lastChange = matches.pop();\n              matches.forEach(function (e) {\n                observer.next(e);\n              });\n\n              _this3.source.next(lastChange); // last match is cached\n\n            }\n\n            observer.complete();\n          });\n          return merge(registration$, matchMedia$);\n        }\n\n        return this._observable$;\n      }\n      /**\n       * Based on the BreakPointRegistry provider, register internal listeners for each unique\n       * mediaQuery. Each listener emits specific MediaChange data to observers\n       */\n\n    }, {\n      key: \"registerQuery\",\n      value: function registerQuery(mediaQuery) {\n        var _this4 = this;\n\n        var list = Array.isArray(mediaQuery) ? mediaQuery : [mediaQuery];\n        var matches = [];\n        buildQueryCss(list, this._document);\n        list.forEach(function (query) {\n          var onMQLEvent = function onMQLEvent(e) {\n            _this4._zone.run(function () {\n              return _this4.source.next(new MediaChange(e.matches, query));\n            });\n          };\n\n          var mql = _this4.registry.get(query);\n\n          if (!mql) {\n            mql = _this4.buildMQL(query);\n            mql.addListener(onMQLEvent);\n\n            _this4.pendingRemoveListenerFns.push(function () {\n              return mql.removeListener(onMQLEvent);\n            });\n\n            _this4.registry.set(query, mql);\n          }\n\n          if (mql.matches) {\n            matches.push(new MediaChange(true, query));\n          }\n        });\n        return matches;\n      }\n    }, {\n      key: \"ngOnDestroy\",\n      value: function ngOnDestroy() {\n        var fn;\n\n        while (fn = this.pendingRemoveListenerFns.pop()) {\n          fn();\n        }\n      }\n      /**\n       * Call window.matchMedia() to build a MediaQueryList; which\n       * supports 0..n listeners for activation/deactivation\n       */\n\n    }, {\n      key: \"buildMQL\",\n      value: function buildMQL(query) {\n        return constructMql(query, isPlatformBrowser(this._platformId));\n      }\n    }]);\n\n    return MatchMedia;\n  }();\n\n  MatchMedia.ɵfac = function MatchMedia_Factory(t) {\n    return new (t || MatchMedia)(i0.ɵɵinject(i0.NgZone), i0.ɵɵinject(PLATFORM_ID), i0.ɵɵinject(DOCUMENT));\n  };\n\n  MatchMedia.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: MatchMedia,\n    factory: MatchMedia.ɵfac,\n    providedIn: 'root'\n  });\n  return MatchMedia;\n})();\n\n/*#__PURE__*/\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Private global registry for all dynamically-created, injected style tags\n * @see prepare(query)\n */\n\n\nvar ALL_STYLES = {};\n/**\n * For Webkit engines that only trigger the MediaQueryList Listener\n * when there is at least one CSS selector for the respective media query.\n *\n * @param mediaQueries\n * @param _document\n */\n\nfunction buildQueryCss(mediaQueries, _document) {\n  var list = mediaQueries.filter(function (it) {\n    return !ALL_STYLES[it];\n  });\n\n  if (list.length > 0) {\n    var query = list.join(', ');\n\n    try {\n      var styleEl = _document.createElement('style');\n\n      styleEl.setAttribute('type', 'text/css');\n\n      if (!styleEl.styleSheet) {\n        var cssText = \"\\n/*\\n  @angular/flex-layout - workaround for possible browser quirk with mediaQuery listeners\\n  see http://bit.ly/2sd4HMP\\n*/\\n@media \".concat(query, \" {.fx-query-test{ }}\\n\");\n        styleEl.appendChild(_document.createTextNode(cssText));\n      }\n\n      _document.head.appendChild(styleEl); // Store in private global registry\n\n\n      list.forEach(function (mq) {\n        return ALL_STYLES[mq] = styleEl;\n      });\n    } catch (e) {\n      console.error(e);\n    }\n  }\n}\n\nfunction constructMql(query, isBrowser) {\n  var canListen = isBrowser && !!window.matchMedia('all').addListener;\n  return canListen ? window.matchMedia(query) : {\n    matches: query === 'all' || query === '',\n    media: query,\n    addListener: function addListener() {},\n    removeListener: function removeListener() {},\n    onchange: null,\n    addEventListener: function addEventListener() {},\n    removeEventListener: function removeEventListener() {},\n    dispatchEvent: function dispatchEvent() {\n      return false;\n    }\n  };\n}\n/**\n * NOTE: Smaller ranges have HIGHER priority since the match is more specific\n */\n\n\nvar DEFAULT_BREAKPOINTS = [{\n  alias: 'xs',\n  mediaQuery: 'screen and (min-width: 0px) and (max-width: 599.98px)',\n  priority: 1000\n}, {\n  alias: 'sm',\n  mediaQuery: 'screen and (min-width: 600px) and (max-width: 959.98px)',\n  priority: 900\n}, {\n  alias: 'md',\n  mediaQuery: 'screen and (min-width: 960px) and (max-width: 1279.98px)',\n  priority: 800\n}, {\n  alias: 'lg',\n  mediaQuery: 'screen and (min-width: 1280px) and (max-width: 1919.98px)',\n  priority: 700\n}, {\n  alias: 'xl',\n  mediaQuery: 'screen and (min-width: 1920px) and (max-width: 4999.98px)',\n  priority: 600\n}, {\n  alias: 'lt-sm',\n  overlapping: true,\n  mediaQuery: 'screen and (max-width: 599.98px)',\n  priority: 950\n}, {\n  alias: 'lt-md',\n  overlapping: true,\n  mediaQuery: 'screen and (max-width: 959.98px)',\n  priority: 850\n}, {\n  alias: 'lt-lg',\n  overlapping: true,\n  mediaQuery: 'screen and (max-width: 1279.98px)',\n  priority: 750\n}, {\n  alias: 'lt-xl',\n  overlapping: true,\n  priority: 650,\n  mediaQuery: 'screen and (max-width: 1919.98px)'\n}, {\n  alias: 'gt-xs',\n  overlapping: true,\n  mediaQuery: 'screen and (min-width: 600px)',\n  priority: -950\n}, {\n  alias: 'gt-sm',\n  overlapping: true,\n  mediaQuery: 'screen and (min-width: 960px)',\n  priority: -850\n}, {\n  alias: 'gt-md',\n  overlapping: true,\n  mediaQuery: 'screen and (min-width: 1280px)',\n  priority: -750\n}, {\n  alias: 'gt-lg',\n  overlapping: true,\n  mediaQuery: 'screen and (min-width: 1920px)',\n  priority: -650\n}];\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/* tslint:disable */\n\nvar HANDSET_PORTRAIT = '(orientation: portrait) and (max-width: 599.98px)';\nvar HANDSET_LANDSCAPE = '(orientation: landscape) and (max-width: 959.98px)';\nvar TABLET_PORTRAIT = '(orientation: portrait) and (min-width: 600px) and (max-width: 839.98px)';\nvar TABLET_LANDSCAPE = '(orientation: landscape) and (min-width: 960px) and (max-width: 1279.98px)';\nvar WEB_PORTRAIT = '(orientation: portrait) and (min-width: 840px)';\nvar WEB_LANDSCAPE = '(orientation: landscape) and (min-width: 1280px)';\nvar ScreenTypes = {\n  'HANDSET': /*#__PURE__*/ /*#__PURE__*/\"\".concat(HANDSET_PORTRAIT, \", \").concat(HANDSET_LANDSCAPE),\n  'TABLET': /*#__PURE__*/ /*#__PURE__*/\"\".concat(TABLET_PORTRAIT, \" , \").concat(TABLET_LANDSCAPE),\n  'WEB': /*#__PURE__*/ /*#__PURE__*/\"\".concat(WEB_PORTRAIT, \", \").concat(WEB_LANDSCAPE, \" \"),\n  'HANDSET_PORTRAIT': /*#__PURE__*/\"\".concat(HANDSET_PORTRAIT),\n  'TABLET_PORTRAIT': /*#__PURE__*/\"\".concat(TABLET_PORTRAIT, \" \"),\n  'WEB_PORTRAIT': /*#__PURE__*/\"\".concat(WEB_PORTRAIT),\n  'HANDSET_LANDSCAPE': /*#__PURE__*/\"\".concat(HANDSET_LANDSCAPE),\n  'TABLET_LANDSCAPE': /*#__PURE__*/\"\".concat(TABLET_LANDSCAPE),\n  'WEB_LANDSCAPE': /*#__PURE__*/\"\".concat(WEB_LANDSCAPE)\n};\n/**\n * Extended Breakpoints for handset/tablets with landscape or portrait orientations\n */\n\nvar ORIENTATION_BREAKPOINTS = [{\n  'alias': 'handset',\n  priority: 2000,\n  'mediaQuery': ScreenTypes.HANDSET\n}, {\n  'alias': 'handset.landscape',\n  priority: 2000,\n  'mediaQuery': ScreenTypes.HANDSET_LANDSCAPE\n}, {\n  'alias': 'handset.portrait',\n  priority: 2000,\n  'mediaQuery': ScreenTypes.HANDSET_PORTRAIT\n}, {\n  'alias': 'tablet',\n  priority: 2100,\n  'mediaQuery': ScreenTypes.TABLET\n}, {\n  'alias': 'tablet.landscape',\n  priority: 2100,\n  'mediaQuery': ScreenTypes.TABLET_LANDSCAPE\n}, {\n  'alias': 'tablet.portrait',\n  priority: 2100,\n  'mediaQuery': ScreenTypes.TABLET_PORTRAIT\n}, {\n  'alias': 'web',\n  priority: 2200,\n  'mediaQuery': ScreenTypes.WEB,\n  overlapping: true\n}, {\n  'alias': 'web.landscape',\n  priority: 2200,\n  'mediaQuery': ScreenTypes.WEB_LANDSCAPE,\n  overlapping: true\n}, {\n  'alias': 'web.portrait',\n  priority: 2200,\n  'mediaQuery': ScreenTypes.WEB_PORTRAIT,\n  overlapping: true\n}];\nvar ALIAS_DELIMITERS = /(\\.|-|_)/g;\n\nfunction firstUpperCase(part) {\n  var first = part.length > 0 ? part.charAt(0) : '';\n  var remainder = part.length > 1 ? part.slice(1) : '';\n  return first.toUpperCase() + remainder;\n}\n/**\n * Converts snake-case to SnakeCase.\n * @param name Text to UpperCamelCase\n */\n\n\nfunction camelCase(name) {\n  return name.replace(ALIAS_DELIMITERS, '|').split('|').map(firstUpperCase).join('');\n}\n/**\n * For each breakpoint, ensure that a Suffix is defined;\n * fallback to UpperCamelCase the unique Alias value\n */\n\n\nfunction validateSuffixes(list) {\n  list.forEach(function (bp) {\n    if (!bp.suffix) {\n      bp.suffix = camelCase(bp.alias); // create Suffix value based on alias\n\n      bp.overlapping = !!bp.overlapping; // ensure default value\n    }\n  });\n  return list;\n}\n/**\n * Merge a custom breakpoint list with the default list based on unique alias values\n *  - Items are added if the alias is not in the default list\n *  - Items are merged with the custom override if the alias exists in the default list\n */\n\n\nfunction mergeByAlias(defaults) {\n  var custom = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  var dict = {};\n  defaults.forEach(function (bp) {\n    dict[bp.alias] = bp;\n  }); // Merge custom breakpoints\n\n  custom.forEach(function (bp) {\n    if (dict[bp.alias]) {\n      extendObject(dict[bp.alias], bp);\n    } else {\n      dict[bp.alias] = bp;\n    }\n  });\n  return validateSuffixes(Object.keys(dict).map(function (k) {\n    return dict[k];\n  }));\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n *  Injection token unique to the flex-layout library.\n *  Use this token when build a custom provider (see below).\n */\n\n\nvar BREAKPOINTS = /*#__PURE__*/new InjectionToken('Token (@angular/flex-layout) Breakpoints', {\n  providedIn: 'root',\n  factory: function factory() {\n    var breakpoints = inject(BREAKPOINT);\n    var layoutConfig = inject(LAYOUT_CONFIG);\n    var bpFlattenArray = [].concat.apply([], (breakpoints || []).map(function (v) {\n      return Array.isArray(v) ? v : [v];\n    }));\n    var builtIns = (layoutConfig.disableDefaultBps ? [] : DEFAULT_BREAKPOINTS).concat(layoutConfig.addOrientationBps ? ORIENTATION_BREAKPOINTS : []);\n    return mergeByAlias(builtIns, bpFlattenArray);\n  }\n});\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Registry of 1..n MediaQuery breakpoint ranges\n * This is published as a provider and may be overridden from custom, application-specific ranges\n *\n */\n\nvar BreakPointRegistry = /*#__PURE__*/(function () {\n  var BreakPointRegistry = /*#__PURE__*/function () {\n    function BreakPointRegistry(list) {\n      _classCallCheck(this, BreakPointRegistry);\n\n      /**\n       * Memoized BreakPoint Lookups\n       */\n      this.findByMap = new Map();\n      this.items = _toConsumableArray(list).sort(sortAscendingPriority);\n    }\n    /**\n     * Search breakpoints by alias (e.g. gt-xs)\n     */\n\n\n    _createClass(BreakPointRegistry, [{\n      key: \"findByAlias\",\n      value: function findByAlias(alias) {\n        return !alias ? null : this.findWithPredicate(alias, function (bp) {\n          return bp.alias == alias;\n        });\n      }\n    }, {\n      key: \"findByQuery\",\n      value: function findByQuery(query) {\n        return this.findWithPredicate(query, function (bp) {\n          return bp.mediaQuery == query;\n        });\n      }\n      /**\n       * Get all the breakpoints whose ranges could overlapping `normal` ranges;\n       * e.g. gt-sm overlaps md, lg, and xl\n       */\n\n    }, {\n      key: \"overlappings\",\n      get: function get() {\n        return this.items.filter(function (it) {\n          return it.overlapping == true;\n        });\n      }\n      /**\n       * Get list of all registered (non-empty) breakpoint aliases\n       */\n\n    }, {\n      key: \"aliases\",\n      get: function get() {\n        return this.items.map(function (it) {\n          return it.alias;\n        });\n      }\n      /**\n       * Aliases are mapped to properties using suffixes\n       * e.g.  'gt-sm' for property 'layout'  uses suffix 'GtSm'\n       * for property layoutGtSM.\n       */\n\n    }, {\n      key: \"suffixes\",\n      get: function get() {\n        return this.items.map(function (it) {\n          return !!it.suffix ? it.suffix : '';\n        });\n      }\n      /**\n       * Memoized lookup using custom predicate function\n       */\n\n    }, {\n      key: \"findWithPredicate\",\n      value: function findWithPredicate(key, searchFn) {\n        var response = this.findByMap.get(key);\n\n        if (!response) {\n          response = this.items.find(searchFn) || null;\n          this.findByMap.set(key, response);\n        }\n\n        return response || null;\n      }\n    }]);\n\n    return BreakPointRegistry;\n  }();\n\n  BreakPointRegistry.ɵfac = function BreakPointRegistry_Factory(t) {\n    return new (t || BreakPointRegistry)(i0.ɵɵinject(BREAKPOINTS));\n  };\n\n  BreakPointRegistry.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: BreakPointRegistry,\n    factory: BreakPointRegistry.ɵfac,\n    providedIn: 'root'\n  });\n  return BreakPointRegistry;\n})();\n\n/*#__PURE__*/\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nvar PRINT = 'print';\nvar BREAKPOINT_PRINT = {\n  alias: PRINT,\n  mediaQuery: PRINT,\n  priority: 1000\n};\n/**\n * PrintHook - Use to intercept print MediaQuery activations and force\n *             layouts to render with the specified print alias/breakpoint\n *\n * Used in MediaMarshaller and MediaObserver\n */\n\nvar PrintHook = /*#__PURE__*/(function () {\n  var PrintHook = /*#__PURE__*/function () {\n    function PrintHook(breakpoints, layoutConfig, _document) {\n      _classCallCheck(this, PrintHook);\n\n      this.breakpoints = breakpoints;\n      this.layoutConfig = layoutConfig;\n      this._document = _document; // registeredBeforeAfterPrintHooks tracks if we registered the `beforeprint`\n      //  and `afterprint` event listeners.\n\n      this.registeredBeforeAfterPrintHooks = false; // isPrintingBeforeAfterEvent is used to track if we are printing from within\n      // a `beforeprint` event handler. This prevents the typicall `stopPrinting`\n      // form `interceptEvents` so that printing is not stopped while the dialog\n      // is still open. This is an extension of the `isPrinting` property on\n      // browsers which support `beforeprint` and `afterprint` events.\n\n      this.isPrintingBeforeAfterEvent = false;\n      this.beforePrintEventListeners = [];\n      this.afterPrintEventListeners = [];\n      /** Is this service currently in Print-mode ? */\n\n      this.isPrinting = false;\n      this.queue = new PrintQueue();\n      this.deactivations = [];\n    }\n    /** Add 'print' mediaQuery: to listen for matchMedia activations */\n\n\n    _createClass(PrintHook, [{\n      key: \"withPrintQuery\",\n      value: function withPrintQuery(queries) {\n        return [].concat(_toConsumableArray(queries), [PRINT]);\n      }\n      /** Is the MediaChange event for any 'print' @media */\n\n    }, {\n      key: \"isPrintEvent\",\n      value: function isPrintEvent(e) {\n        return e.mediaQuery.startsWith(PRINT);\n      }\n      /** What is the desired mqAlias to use while printing? */\n\n    }, {\n      key: \"printAlias\",\n      get: function get() {\n        return this.layoutConfig.printWithBreakpoints || [];\n      }\n      /** Lookup breakpoints associated with print aliases. */\n\n    }, {\n      key: \"printBreakPoints\",\n      get: function get() {\n        var _this5 = this;\n\n        return this.printAlias.map(function (alias) {\n          return _this5.breakpoints.findByAlias(alias);\n        }).filter(function (bp) {\n          return bp !== null;\n        });\n      }\n      /** Lookup breakpoint associated with mediaQuery */\n\n    }, {\n      key: \"getEventBreakpoints\",\n      value: function getEventBreakpoints(_ref) {\n        var mediaQuery = _ref.mediaQuery;\n        var bp = this.breakpoints.findByQuery(mediaQuery);\n        var list = bp ? [].concat(_toConsumableArray(this.printBreakPoints), [bp]) : this.printBreakPoints;\n        return list.sort(sortDescendingPriority);\n      }\n      /** Update event with printAlias mediaQuery information */\n\n    }, {\n      key: \"updateEvent\",\n      value: function updateEvent(event) {\n        var bp = this.breakpoints.findByQuery(event.mediaQuery);\n\n        if (this.isPrintEvent(event)) {\n          // Reset from 'print' to first (highest priority) print breakpoint\n          bp = this.getEventBreakpoints(event)[0];\n          event.mediaQuery = bp ? bp.mediaQuery : '';\n        }\n\n        return mergeAlias(event, bp);\n      } // registerBeforeAfterPrintHooks registers a `beforeprint` event hook so we can\n      // trigger print styles synchronously and apply proper layout styles.\n      // It is a noop if the hooks have already been registered or if the document's\n      // `defaultView` is not available.\n\n    }, {\n      key: \"registerBeforeAfterPrintHooks\",\n      value: function registerBeforeAfterPrintHooks(target) {\n        var _this6 = this;\n\n        // `defaultView` may be null when rendering on the server or in other contexts.\n        if (!this._document.defaultView || this.registeredBeforeAfterPrintHooks) {\n          return;\n        }\n\n        this.registeredBeforeAfterPrintHooks = true;\n\n        var beforePrintListener = function beforePrintListener() {\n          // If we aren't already printing, start printing and update the styles as\n          // if there was a regular print `MediaChange`(from matchMedia).\n          if (!_this6.isPrinting) {\n            _this6.isPrintingBeforeAfterEvent = true;\n\n            _this6.startPrinting(target, _this6.getEventBreakpoints(new MediaChange(true, PRINT)));\n\n            target.updateStyles();\n          }\n        };\n\n        var afterPrintListener = function afterPrintListener() {\n          // If we aren't already printing, start printing and update the styles as\n          // if there was a regular print `MediaChange`(from matchMedia).\n          _this6.isPrintingBeforeAfterEvent = false;\n\n          if (_this6.isPrinting) {\n            _this6.stopPrinting(target);\n\n            target.updateStyles();\n          }\n        }; // Could we have teardown logic to remove if there are no print listeners being used?\n\n\n        this._document.defaultView.addEventListener('beforeprint', beforePrintListener);\n\n        this._document.defaultView.addEventListener('afterprint', afterPrintListener);\n\n        this.beforePrintEventListeners.push(beforePrintListener);\n        this.afterPrintEventListeners.push(afterPrintListener);\n      }\n      /**\n       * Prepare RxJS filter operator with partial application\n       * @return pipeable filter predicate\n       */\n\n    }, {\n      key: \"interceptEvents\",\n      value: function interceptEvents(target) {\n        var _this7 = this;\n\n        this.registerBeforeAfterPrintHooks(target);\n        return function (event) {\n          if (_this7.isPrintEvent(event)) {\n            if (event.matches && !_this7.isPrinting) {\n              _this7.startPrinting(target, _this7.getEventBreakpoints(event));\n\n              target.updateStyles();\n            } else if (!event.matches && _this7.isPrinting && !_this7.isPrintingBeforeAfterEvent) {\n              _this7.stopPrinting(target);\n\n              target.updateStyles();\n            }\n          } else {\n            _this7.collectActivations(event);\n          }\n        };\n      }\n      /** Stop mediaChange event propagation in event streams */\n\n    }, {\n      key: \"blockPropagation\",\n      value: function blockPropagation() {\n        var _this8 = this;\n\n        return function (event) {\n          return !(_this8.isPrinting || _this8.isPrintEvent(event));\n        };\n      }\n      /**\n       * Save current activateBreakpoints (for later restore)\n       * and substitute only the printAlias breakpoint\n       */\n\n    }, {\n      key: \"startPrinting\",\n      value: function startPrinting(target, bpList) {\n        this.isPrinting = true;\n        target.activatedBreakpoints = this.queue.addPrintBreakpoints(bpList);\n      }\n      /** For any print de-activations, reset the entire print queue */\n\n    }, {\n      key: \"stopPrinting\",\n      value: function stopPrinting(target) {\n        target.activatedBreakpoints = this.deactivations;\n        this.deactivations = [];\n        this.queue.clear();\n        this.isPrinting = false;\n      }\n      /**\n       * To restore pre-Print Activations, we must capture the proper\n       * list of breakpoint activations BEFORE print starts. OnBeforePrint()\n       * is supported; so 'print' mediaQuery activations are used as a fallback\n       * in browsers without `beforeprint` support.\n       *\n       * >  But activated breakpoints are deactivated BEFORE 'print' activation.\n       *\n       * Let's capture all de-activations using the following logic:\n       *\n       *  When not printing:\n       *    - clear cache when activating non-print breakpoint\n       *    - update cache (and sort) when deactivating\n       *\n       *  When printing:\n       *    - sort and save when starting print\n       *    - restore as activatedTargets and clear when stop printing\n       */\n\n    }, {\n      key: \"collectActivations\",\n      value: function collectActivations(event) {\n        if (!this.isPrinting || this.isPrintingBeforeAfterEvent) {\n          if (!event.matches) {\n            var bp = this.breakpoints.findByQuery(event.mediaQuery);\n\n            if (bp) {\n              // Deactivating a breakpoint\n              this.deactivations.push(bp);\n              this.deactivations.sort(sortDescendingPriority);\n            }\n          } else if (!this.isPrintingBeforeAfterEvent) {\n            // Only clear deactivations if we aren't printing from a `beforeprint` event.\n            // Otherwise this will clear before `stopPrinting()` is called to restore\n            // the pre-Print Activations.\n            this.deactivations = [];\n          }\n        }\n      }\n      /** Teardown logic for the service. */\n\n    }, {\n      key: \"ngOnDestroy\",\n      value: function ngOnDestroy() {\n        var _this9 = this;\n\n        if (this._document.defaultView) {\n          this.beforePrintEventListeners.forEach(function (l) {\n            return _this9._document.defaultView.removeEventListener('beforeprint', l);\n          });\n          this.afterPrintEventListeners.forEach(function (l) {\n            return _this9._document.defaultView.removeEventListener('afterprint', l);\n          });\n        }\n      }\n    }]);\n\n    return PrintHook;\n  }();\n\n  PrintHook.ɵfac = function PrintHook_Factory(t) {\n    return new (t || PrintHook)(i0.ɵɵinject(BreakPointRegistry), i0.ɵɵinject(LAYOUT_CONFIG), i0.ɵɵinject(DOCUMENT));\n  };\n\n  PrintHook.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: PrintHook,\n    factory: PrintHook.ɵfac,\n    providedIn: 'root'\n  });\n  return PrintHook;\n})();\n\n/*#__PURE__*/\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})(); // ************************************************************************\n// Internal Utility class 'PrintQueue'\n// ************************************************************************\n\n/**\n * Utility class to manage print breakpoints + activatedBreakpoints\n * with correct sorting WHILE printing\n */\n\n\nvar PrintQueue = /*#__PURE__*/function () {\n  function PrintQueue() {\n    _classCallCheck(this, PrintQueue);\n\n    /** Sorted queue with prioritized print breakpoints */\n    this.printBreakpoints = [];\n  }\n\n  _createClass(PrintQueue, [{\n    key: \"addPrintBreakpoints\",\n    value: function addPrintBreakpoints(bpList) {\n      var _this10 = this;\n\n      bpList.push(BREAKPOINT_PRINT);\n      bpList.sort(sortDescendingPriority);\n      bpList.forEach(function (bp) {\n        return _this10.addBreakpoint(bp);\n      });\n      return this.printBreakpoints;\n    }\n    /** Add Print breakpoint to queue */\n\n  }, {\n    key: \"addBreakpoint\",\n    value: function addBreakpoint(bp) {\n      if (!!bp) {\n        var bpInList = this.printBreakpoints.find(function (it) {\n          return it.mediaQuery === bp.mediaQuery;\n        });\n\n        if (bpInList === undefined) {\n          // If this is a `printAlias` breakpoint, then append. If a true 'print' breakpoint,\n          // register as highest priority in the queue\n          this.printBreakpoints = isPrintBreakPoint(bp) ? [bp].concat(_toConsumableArray(this.printBreakpoints)) : [].concat(_toConsumableArray(this.printBreakpoints), [bp]);\n        }\n      }\n    }\n    /** Restore original activated breakpoints and clear internal caches */\n\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this.printBreakpoints = [];\n    }\n  }]);\n\n  return PrintQueue;\n}(); // ************************************************************************\n// Internal Utility methods\n// ************************************************************************\n\n/** Only support intercept queueing if the Breakpoint is a print @media query */\n\n\nfunction isPrintBreakPoint(bp) {\n  return bp ? bp.mediaQuery.startsWith(PRINT) : false;\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * MediaMarshaller - register responsive values from directives and\n *                   trigger them based on media query events\n */\n\n\nvar MediaMarshaller = /*#__PURE__*/(function () {\n  var MediaMarshaller = /*#__PURE__*/function () {\n    function MediaMarshaller(matchMedia, breakpoints, hook) {\n      _classCallCheck(this, MediaMarshaller);\n\n      this.matchMedia = matchMedia;\n      this.breakpoints = breakpoints;\n      this.hook = hook;\n      this.activatedBreakpoints = [];\n      this.elementMap = new Map();\n      this.elementKeyMap = new WeakMap();\n      this.watcherMap = new WeakMap(); // special triggers to update elements\n\n      this.updateMap = new WeakMap(); // callback functions to update styles\n\n      this.clearMap = new WeakMap(); // callback functions to clear styles\n\n      this.subject = new Subject();\n      this.observeActivations();\n    }\n\n    _createClass(MediaMarshaller, [{\n      key: \"activatedAlias\",\n      get: function get() {\n        return this.activatedBreakpoints[0] ? this.activatedBreakpoints[0].alias : '';\n      }\n      /**\n       * Update styles on breakpoint activates or deactivates\n       * @param mc\n       */\n\n    }, {\n      key: \"onMediaChange\",\n      value: function onMediaChange(mc) {\n        var bp = this.findByQuery(mc.mediaQuery);\n\n        if (bp) {\n          mc = mergeAlias(mc, bp);\n\n          if (mc.matches && this.activatedBreakpoints.indexOf(bp) === -1) {\n            this.activatedBreakpoints.push(bp);\n            this.activatedBreakpoints.sort(sortDescendingPriority);\n            this.updateStyles();\n          } else if (!mc.matches && this.activatedBreakpoints.indexOf(bp) !== -1) {\n            // Remove the breakpoint when it's deactivated\n            this.activatedBreakpoints.splice(this.activatedBreakpoints.indexOf(bp), 1);\n            this.activatedBreakpoints.sort(sortDescendingPriority);\n            this.updateStyles();\n          }\n        }\n      }\n      /**\n       * initialize the marshaller with necessary elements for delegation on an element\n       * @param element\n       * @param key\n       * @param updateFn optional callback so that custom bp directives don't have to re-provide this\n       * @param clearFn optional callback so that custom bp directives don't have to re-provide this\n       * @param extraTriggers other triggers to force style updates (e.g. layout, directionality, etc)\n       */\n\n    }, {\n      key: \"init\",\n      value: function init(element, key, updateFn, clearFn) {\n        var extraTriggers = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [];\n        initBuilderMap(this.updateMap, element, key, updateFn);\n        initBuilderMap(this.clearMap, element, key, clearFn);\n        this.buildElementKeyMap(element, key);\n        this.watchExtraTriggers(element, key, extraTriggers);\n      }\n      /**\n       * get the value for an element and key and optionally a given breakpoint\n       * @param element\n       * @param key\n       * @param bp\n       */\n\n    }, {\n      key: \"getValue\",\n      value: function getValue(element, key, bp) {\n        var bpMap = this.elementMap.get(element);\n\n        if (bpMap) {\n          var values = bp !== undefined ? bpMap.get(bp) : this.getActivatedValues(bpMap, key);\n\n          if (values) {\n            return values.get(key);\n          }\n        }\n\n        return undefined;\n      }\n      /**\n       * whether the element has values for a given key\n       * @param element\n       * @param key\n       */\n\n    }, {\n      key: \"hasValue\",\n      value: function hasValue(element, key) {\n        var bpMap = this.elementMap.get(element);\n\n        if (bpMap) {\n          var values = this.getActivatedValues(bpMap, key);\n\n          if (values) {\n            return values.get(key) !== undefined || false;\n          }\n        }\n\n        return false;\n      }\n      /**\n       * Set the value for an input on a directive\n       * @param element the element in question\n       * @param key the type of the directive (e.g. flex, layout-gap, etc)\n       * @param bp the breakpoint suffix (empty string = default)\n       * @param val the value for the breakpoint\n       */\n\n    }, {\n      key: \"setValue\",\n      value: function setValue(element, key, val, bp) {\n        var bpMap = this.elementMap.get(element);\n\n        if (!bpMap) {\n          bpMap = new Map().set(bp, new Map().set(key, val));\n          this.elementMap.set(element, bpMap);\n        } else {\n          var values = (bpMap.get(bp) || new Map()).set(key, val);\n          bpMap.set(bp, values);\n          this.elementMap.set(element, bpMap);\n        }\n\n        var value = this.getValue(element, key);\n\n        if (value !== undefined) {\n          this.updateElement(element, key, value);\n        }\n      }\n      /** Track element value changes for a specific key */\n\n    }, {\n      key: \"trackValue\",\n      value: function trackValue(element, key) {\n        return this.subject.asObservable().pipe(filter(function (v) {\n          return v.element === element && v.key === key;\n        }));\n      }\n      /** update all styles for all elements on the current breakpoint */\n\n    }, {\n      key: \"updateStyles\",\n      value: function updateStyles() {\n        var _this11 = this;\n\n        this.elementMap.forEach(function (bpMap, el) {\n          var keyMap = new Set(_this11.elementKeyMap.get(el));\n\n          var valueMap = _this11.getActivatedValues(bpMap);\n\n          if (valueMap) {\n            valueMap.forEach(function (v, k) {\n              _this11.updateElement(el, k, v);\n\n              keyMap.delete(k);\n            });\n          }\n\n          keyMap.forEach(function (k) {\n            valueMap = _this11.getActivatedValues(bpMap, k);\n\n            if (valueMap) {\n              var value = valueMap.get(k);\n\n              _this11.updateElement(el, k, value);\n            } else {\n              _this11.clearElement(el, k);\n            }\n          });\n        });\n      }\n      /**\n       * clear the styles for a given element\n       * @param element\n       * @param key\n       */\n\n    }, {\n      key: \"clearElement\",\n      value: function clearElement(element, key) {\n        var builders = this.clearMap.get(element);\n\n        if (builders) {\n          var clearFn = builders.get(key);\n\n          if (!!clearFn) {\n            clearFn();\n            this.subject.next({\n              element: element,\n              key: key,\n              value: ''\n            });\n          }\n        }\n      }\n      /**\n       * update a given element with the activated values for a given key\n       * @param element\n       * @param key\n       * @param value\n       */\n\n    }, {\n      key: \"updateElement\",\n      value: function updateElement(element, key, value) {\n        var builders = this.updateMap.get(element);\n\n        if (builders) {\n          var updateFn = builders.get(key);\n\n          if (!!updateFn) {\n            updateFn(value);\n            this.subject.next({\n              element: element,\n              key: key,\n              value: value\n            });\n          }\n        }\n      }\n      /**\n       * release all references to a given element\n       * @param element\n       */\n\n    }, {\n      key: \"releaseElement\",\n      value: function releaseElement(element) {\n        var watcherMap = this.watcherMap.get(element);\n\n        if (watcherMap) {\n          watcherMap.forEach(function (s) {\n            return s.unsubscribe();\n          });\n          this.watcherMap.delete(element);\n        }\n\n        var elementMap = this.elementMap.get(element);\n\n        if (elementMap) {\n          elementMap.forEach(function (_, s) {\n            return elementMap.delete(s);\n          });\n          this.elementMap.delete(element);\n        }\n      }\n      /**\n       * trigger an update for a given element and key (e.g. layout)\n       * @param element\n       * @param key\n       */\n\n    }, {\n      key: \"triggerUpdate\",\n      value: function triggerUpdate(element, key) {\n        var _this12 = this;\n\n        var bpMap = this.elementMap.get(element);\n\n        if (bpMap) {\n          var valueMap = this.getActivatedValues(bpMap, key);\n\n          if (valueMap) {\n            if (key) {\n              this.updateElement(element, key, valueMap.get(key));\n            } else {\n              valueMap.forEach(function (v, k) {\n                return _this12.updateElement(element, k, v);\n              });\n            }\n          }\n        }\n      }\n      /** Cross-reference for HTMLElement with directive key */\n\n    }, {\n      key: \"buildElementKeyMap\",\n      value: function buildElementKeyMap(element, key) {\n        var keyMap = this.elementKeyMap.get(element);\n\n        if (!keyMap) {\n          keyMap = new Set();\n          this.elementKeyMap.set(element, keyMap);\n        }\n\n        keyMap.add(key);\n      }\n      /**\n       * Other triggers that should force style updates:\n       * - directionality\n       * - layout changes\n       * - mutationobserver updates\n       */\n\n    }, {\n      key: \"watchExtraTriggers\",\n      value: function watchExtraTriggers(element, key, triggers) {\n        var _this13 = this;\n\n        if (triggers && triggers.length) {\n          var watchers = this.watcherMap.get(element);\n\n          if (!watchers) {\n            watchers = new Map();\n            this.watcherMap.set(element, watchers);\n          }\n\n          var subscription = watchers.get(key);\n\n          if (!subscription) {\n            var newSubscription = merge.apply(void 0, _toConsumableArray(triggers)).subscribe(function () {\n              var currentValue = _this13.getValue(element, key);\n\n              _this13.updateElement(element, key, currentValue);\n            });\n            watchers.set(key, newSubscription);\n          }\n        }\n      }\n      /** Breakpoint locator by mediaQuery */\n\n    }, {\n      key: \"findByQuery\",\n      value: function findByQuery(query) {\n        return this.breakpoints.findByQuery(query);\n      }\n      /**\n       * get the fallback breakpoint for a given element, starting with the current breakpoint\n       * @param bpMap\n       * @param key\n       */\n\n    }, {\n      key: \"getActivatedValues\",\n      value: function getActivatedValues(bpMap, key) {\n        for (var i = 0; i < this.activatedBreakpoints.length; i++) {\n          var activatedBp = this.activatedBreakpoints[i];\n          var valueMap = bpMap.get(activatedBp.alias);\n\n          if (valueMap) {\n            if (key === undefined || valueMap.has(key) && valueMap.get(key) != null) {\n              return valueMap;\n            }\n          }\n        }\n\n        var lastHope = bpMap.get('');\n        return key === undefined || lastHope && lastHope.has(key) ? lastHope : undefined;\n      }\n      /**\n       * Watch for mediaQuery breakpoint activations\n       */\n\n    }, {\n      key: \"observeActivations\",\n      value: function observeActivations() {\n        var target = this;\n        var queries = this.breakpoints.items.map(function (bp) {\n          return bp.mediaQuery;\n        });\n        this.matchMedia.observe(this.hook.withPrintQuery(queries)).pipe(tap(this.hook.interceptEvents(target)), filter(this.hook.blockPropagation())).subscribe(this.onMediaChange.bind(this));\n      }\n    }]);\n\n    return MediaMarshaller;\n  }();\n\n  MediaMarshaller.ɵfac = function MediaMarshaller_Factory(t) {\n    return new (t || MediaMarshaller)(i0.ɵɵinject(MatchMedia), i0.ɵɵinject(BreakPointRegistry), i0.ɵɵinject(PrintHook));\n  };\n\n  MediaMarshaller.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: MediaMarshaller,\n    factory: MediaMarshaller.ɵfac,\n    providedIn: 'root'\n  });\n  return MediaMarshaller;\n})();\n\n/*#__PURE__*/\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nfunction initBuilderMap(map, element, key, input) {\n  if (input !== undefined) {\n    var oldMap = map.get(element);\n\n    if (!oldMap) {\n      oldMap = new Map();\n      map.set(element, oldMap);\n    }\n\n    oldMap.set(key, input);\n  }\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nvar BaseDirective2 = /*#__PURE__*/(function () {\n  var BaseDirective2 = /*#__PURE__*/function () {\n    function BaseDirective2(elementRef, styleBuilder, styler, marshal) {\n      _classCallCheck(this, BaseDirective2);\n\n      this.elementRef = elementRef;\n      this.styleBuilder = styleBuilder;\n      this.styler = styler;\n      this.marshal = marshal;\n      this.DIRECTIVE_KEY = '';\n      this.inputs = [];\n      /** The most recently used styles for the builder */\n\n      this.mru = {};\n      this.destroySubject = new Subject();\n      /** Cache map for style computation */\n\n      this.styleCache = new Map();\n    }\n    /** Access to host element's parent DOM node */\n\n\n    _createClass(BaseDirective2, [{\n      key: \"parentElement\",\n      get: function get() {\n        return this.elementRef.nativeElement.parentElement;\n      }\n      /** Access to the HTMLElement for the directive */\n\n    }, {\n      key: \"nativeElement\",\n      get: function get() {\n        return this.elementRef.nativeElement;\n      }\n      /** Access to the activated value for the directive */\n\n    }, {\n      key: \"activatedValue\",\n      get: function get() {\n        return this.marshal.getValue(this.nativeElement, this.DIRECTIVE_KEY);\n      },\n      set: function set(value) {\n        this.marshal.setValue(this.nativeElement, this.DIRECTIVE_KEY, value, this.marshal.activatedAlias);\n      }\n      /** For @Input changes */\n\n    }, {\n      key: \"ngOnChanges\",\n      value: function ngOnChanges(changes) {\n        var _this14 = this;\n\n        Object.keys(changes).forEach(function (key) {\n          if (_this14.inputs.indexOf(key) !== -1) {\n            var bp = key.split('.').slice(1).join('.');\n            var val = changes[key].currentValue;\n\n            _this14.setValue(val, bp);\n          }\n        });\n      }\n    }, {\n      key: \"ngOnDestroy\",\n      value: function ngOnDestroy() {\n        this.destroySubject.next();\n        this.destroySubject.complete();\n        this.marshal.releaseElement(this.nativeElement);\n      }\n      /** Register with central marshaller service */\n\n    }, {\n      key: \"init\",\n      value: function init() {\n        var extraTriggers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n        this.marshal.init(this.elementRef.nativeElement, this.DIRECTIVE_KEY, this.updateWithValue.bind(this), this.clearStyles.bind(this), extraTriggers);\n      }\n      /** Add styles to the element using predefined style builder */\n\n    }, {\n      key: \"addStyles\",\n      value: function addStyles(input, parent) {\n        var builder = this.styleBuilder;\n        var useCache = builder.shouldCache;\n        var genStyles = this.styleCache.get(input);\n\n        if (!genStyles || !useCache) {\n          genStyles = builder.buildStyles(input, parent);\n\n          if (useCache) {\n            this.styleCache.set(input, genStyles);\n          }\n        }\n\n        this.mru = Object.assign({}, genStyles);\n        this.applyStyleToElement(genStyles);\n        builder.sideEffect(input, genStyles, parent);\n      }\n      /** Remove generated styles from an element using predefined style builder */\n\n    }, {\n      key: \"clearStyles\",\n      value: function clearStyles() {\n        var _this15 = this;\n\n        Object.keys(this.mru).forEach(function (k) {\n          _this15.mru[k] = '';\n        });\n        this.applyStyleToElement(this.mru);\n        this.mru = {};\n      }\n      /** Force trigger style updates on DOM element */\n\n    }, {\n      key: \"triggerUpdate\",\n      value: function triggerUpdate() {\n        this.marshal.triggerUpdate(this.nativeElement, this.DIRECTIVE_KEY);\n      }\n      /**\n       * Determine the DOM element's Flexbox flow (flex-direction).\n       *\n       * Check inline style first then check computed (stylesheet) style.\n       * And optionally add the flow value to element's inline style.\n       */\n\n    }, {\n      key: \"getFlexFlowDirection\",\n      value: function getFlexFlowDirection(target) {\n        var addIfMissing = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n        if (target) {\n          var _this$styler$getFlowD = this.styler.getFlowDirection(target),\n              _this$styler$getFlowD2 = _slicedToArray(_this$styler$getFlowD, 2),\n              value = _this$styler$getFlowD2[0],\n              hasInlineValue = _this$styler$getFlowD2[1];\n\n          if (!hasInlineValue && addIfMissing) {\n            var style = buildLayoutCSS(value);\n            var elements = [target];\n            this.styler.applyStyleToElements(style, elements);\n          }\n\n          return value.trim();\n        }\n\n        return 'row';\n      }\n    }, {\n      key: \"hasWrap\",\n      value: function hasWrap(target) {\n        return this.styler.hasWrap(target);\n      }\n      /** Applies styles given via string pair or object map to the directive element */\n\n    }, {\n      key: \"applyStyleToElement\",\n      value: function applyStyleToElement(style, value) {\n        var element = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.nativeElement;\n        this.styler.applyStyleToElement(element, style, value);\n      }\n    }, {\n      key: \"setValue\",\n      value: function setValue(val, bp) {\n        this.marshal.setValue(this.nativeElement, this.DIRECTIVE_KEY, val, bp);\n      }\n    }, {\n      key: \"updateWithValue\",\n      value: function updateWithValue(input) {\n        if (this.currentValue !== input) {\n          this.addStyles(input);\n          this.currentValue = input;\n        }\n      }\n    }]);\n\n    return BaseDirective2;\n  }();\n\n  BaseDirective2.ɵfac = function BaseDirective2_Factory(t) {\n    return new (t || BaseDirective2)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(StyleBuilder), i0.ɵɵdirectiveInject(StyleUtils), i0.ɵɵdirectiveInject(MediaMarshaller));\n  };\n\n  BaseDirective2.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: BaseDirective2,\n    features: [i0.ɵɵNgOnChangesFeature]\n  });\n  return BaseDirective2;\n})();\n\n/*#__PURE__*/\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * MockMatchMedia mocks calls to the Window API matchMedia with a build of a simulated\n * MockMediaQueryListener. Methods are available to simulate an activation of a mediaQuery\n * range and to clearAll mediaQuery listeners.\n */\n\n\nvar MockMatchMedia = /*#__PURE__*/(function () {\n  var MockMatchMedia = /*#__PURE__*/function (_MatchMedia) {\n    _inherits(MockMatchMedia, _MatchMedia);\n\n    var _super = _createSuper(MockMatchMedia);\n\n    function MockMatchMedia(_zone, _platformId, _document, _breakpoints) {\n      var _this16;\n\n      _classCallCheck(this, MockMatchMedia);\n\n      _this16 = _super.call(this, _zone, _platformId, _document);\n      _this16._breakpoints = _breakpoints;\n      _this16.autoRegisterQueries = true; // Used for testing BreakPoint registrations\n\n      _this16.useOverlaps = false; // Allow fallback to overlapping mediaQueries\n\n      return _this16;\n    }\n    /** Easy method to clear all listeners for all mediaQueries */\n\n\n    _createClass(MockMatchMedia, [{\n      key: \"clearAll\",\n      value: function clearAll() {\n        this.registry.forEach(function (mql) {\n          mql.destroy();\n        });\n        this.registry.clear();\n        this.useOverlaps = false;\n      }\n      /** Feature to support manual, simulated activation of a mediaQuery. */\n\n    }, {\n      key: \"activate\",\n      value: function activate(mediaQuery) {\n        var useOverlaps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n        useOverlaps = useOverlaps || this.useOverlaps;\n        mediaQuery = this._validateQuery(mediaQuery);\n\n        if (useOverlaps || !this.isActive(mediaQuery)) {\n          this._deactivateAll();\n\n          this._registerMediaQuery(mediaQuery);\n\n          this._activateWithOverlaps(mediaQuery, useOverlaps);\n        }\n\n        return this.hasActivated;\n      }\n      /** Converts an optional mediaQuery alias to a specific, valid mediaQuery */\n\n    }, {\n      key: \"_validateQuery\",\n      value: function _validateQuery(queryOrAlias) {\n        var bp = this._breakpoints.findByAlias(queryOrAlias);\n\n        return bp && bp.mediaQuery || queryOrAlias;\n      }\n      /**\n       * Manually onMediaChange any overlapping mediaQueries to simulate\n       * similar functionality in the window.matchMedia()\n       */\n\n    }, {\n      key: \"_activateWithOverlaps\",\n      value: function _activateWithOverlaps(mediaQuery, useOverlaps) {\n        if (useOverlaps) {\n          var bp = this._breakpoints.findByQuery(mediaQuery);\n\n          var alias = bp ? bp.alias : 'unknown'; // Simulate activation of overlapping lt-<XXX> ranges\n\n          switch (alias) {\n            case 'lg':\n              this._activateByAlias(['lt-xl']);\n\n              break;\n\n            case 'md':\n              this._activateByAlias(['lt-xl', 'lt-lg']);\n\n              break;\n\n            case 'sm':\n              this._activateByAlias(['lt-xl', 'lt-lg', 'lt-md']);\n\n              break;\n\n            case 'xs':\n              this._activateByAlias(['lt-xl', 'lt-lg', 'lt-md', 'lt-sm']);\n\n              break;\n          } // Simulate activation of overlapping gt-<xxxx> mediaQuery ranges\n\n\n          switch (alias) {\n            case 'xl':\n              this._activateByAlias(['gt-lg', 'gt-md', 'gt-sm', 'gt-xs']);\n\n              break;\n\n            case 'lg':\n              this._activateByAlias(['gt-md', 'gt-sm', 'gt-xs']);\n\n              break;\n\n            case 'md':\n              this._activateByAlias(['gt-sm', 'gt-xs']);\n\n              break;\n\n            case 'sm':\n              this._activateByAlias(['gt-xs']);\n\n              break;\n          }\n        } // Activate last since the responsiveActivation is watching *this* mediaQuery\n\n\n        return this._activateByQuery(mediaQuery);\n      }\n      /**\n       *\n       */\n\n    }, {\n      key: \"_activateByAlias\",\n      value: function _activateByAlias(aliases) {\n        var _this17 = this;\n\n        var activate = function activate(alias) {\n          var bp = _this17._breakpoints.findByAlias(alias);\n\n          _this17._activateByQuery(bp ? bp.mediaQuery : alias);\n        };\n\n        aliases.forEach(activate);\n      }\n      /**\n       *\n       */\n\n    }, {\n      key: \"_activateByQuery\",\n      value: function _activateByQuery(mediaQuery) {\n        if (!this.registry.has(mediaQuery) && this.autoRegisterQueries) {\n          this._registerMediaQuery(mediaQuery);\n        }\n\n        var mql = this.registry.get(mediaQuery);\n\n        if (mql && !this.isActive(mediaQuery)) {\n          this.registry.set(mediaQuery, mql.activate());\n        }\n\n        return this.hasActivated;\n      }\n      /** Deactivate all current MQLs and reset the buffer */\n\n    }, {\n      key: \"_deactivateAll\",\n      value: function _deactivateAll() {\n        this.registry.forEach(function (it) {\n          it.deactivate();\n        });\n        return this;\n      }\n      /** Insure the mediaQuery is registered with MatchMedia */\n\n    }, {\n      key: \"_registerMediaQuery\",\n      value: function _registerMediaQuery(mediaQuery) {\n        if (!this.registry.has(mediaQuery) && this.autoRegisterQueries) {\n          this.registerQuery(mediaQuery);\n        }\n      }\n      /**\n       * Call window.matchMedia() to build a MediaQueryList; which\n       * supports 0..n listeners for activation/deactivation\n       */\n\n    }, {\n      key: \"buildMQL\",\n      value: function buildMQL(query) {\n        return new MockMediaQueryList(query);\n      }\n    }, {\n      key: \"hasActivated\",\n      get: function get() {\n        return this.activations.length > 0;\n      }\n    }]);\n\n    return MockMatchMedia;\n  }(MatchMedia);\n\n  MockMatchMedia.ɵfac = function MockMatchMedia_Factory(t) {\n    return new (t || MockMatchMedia)(i0.ɵɵinject(i0.NgZone), i0.ɵɵinject(PLATFORM_ID), i0.ɵɵinject(DOCUMENT), i0.ɵɵinject(BreakPointRegistry));\n  };\n\n  MockMatchMedia.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: MockMatchMedia,\n    factory: MockMatchMedia.ɵfac\n  });\n  return MockMatchMedia;\n})();\n\n/*#__PURE__*/\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Special internal class to simulate a MediaQueryList and\n * - supports manual activation to simulate mediaQuery matching\n * - manages listeners\n */\n\n\nvar MockMediaQueryList = /*#__PURE__*/function () {\n  function MockMediaQueryList(_mediaQuery) {\n    _classCallCheck(this, MockMediaQueryList);\n\n    this._mediaQuery = _mediaQuery;\n    this._isActive = false;\n    this._listeners = [];\n    this.onchange = null;\n  }\n\n  _createClass(MockMediaQueryList, [{\n    key: \"matches\",\n    get: function get() {\n      return this._isActive;\n    }\n  }, {\n    key: \"media\",\n    get: function get() {\n      return this._mediaQuery;\n    }\n    /**\n     * Destroy the current list by deactivating the\n     * listeners and clearing the internal list\n     */\n\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this.deactivate();\n      this._listeners = [];\n    }\n    /** Notify all listeners that 'matches === TRUE' */\n\n  }, {\n    key: \"activate\",\n    value: function activate() {\n      var _this18 = this;\n\n      if (!this._isActive) {\n        this._isActive = true;\n\n        this._listeners.forEach(function (callback) {\n          var cb = callback;\n          cb.call(_this18, {\n            matches: _this18.matches,\n            media: _this18.media\n          });\n        });\n      }\n\n      return this;\n    }\n    /** Notify all listeners that 'matches === false' */\n\n  }, {\n    key: \"deactivate\",\n    value: function deactivate() {\n      var _this19 = this;\n\n      if (this._isActive) {\n        this._isActive = false;\n\n        this._listeners.forEach(function (callback) {\n          var cb = callback;\n          cb.call(_this19, {\n            matches: _this19.matches,\n            media: _this19.media\n          });\n        });\n      }\n\n      return this;\n    }\n    /** Add a listener to our internal list to activate later */\n\n  }, {\n    key: \"addListener\",\n    value: function addListener(listener) {\n      if (this._listeners.indexOf(listener) === -1) {\n        this._listeners.push(listener);\n      }\n\n      if (this._isActive) {\n        var cb = listener;\n        cb.call(this, {\n          matches: this.matches,\n          media: this.media\n        });\n      }\n    }\n    /** Don't need to remove listeners in the testing environment */\n\n  }, {\n    key: \"removeListener\",\n    value: function removeListener(_) {}\n  }, {\n    key: \"addEventListener\",\n    value: function addEventListener(_, __, ___) {}\n  }, {\n    key: \"removeEventListener\",\n    value: function removeEventListener(_, __, ___) {}\n  }, {\n    key: \"dispatchEvent\",\n    value: function dispatchEvent(_) {\n      return false;\n    }\n  }]);\n\n  return MockMediaQueryList;\n}();\n/**\n * Pre-configured provider for MockMatchMedia\n */\n\n\nvar MockMatchMediaProvider = {\n  provide: MatchMedia,\n  useClass: MockMatchMedia\n};\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/** Wraps the provided value in an array, unless the provided value is an array. */\n\nfunction coerceArray(value) {\n  return Array.isArray(value) ? value : [value];\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * MediaObserver enables applications to listen for 1..n mediaQuery activations and to determine\n * if a mediaQuery is currently activated.\n *\n * Since a breakpoint change will first deactivate 1...n mediaQueries and then possibly activate\n * 1..n mediaQueries, the MediaObserver will debounce notifications and report ALL *activations*\n * in 1 event notification. The reported activations will be sorted in descending priority order.\n *\n * This class uses the BreakPoint Registry to inject alias information into the raw MediaChange\n * notification. For custom mediaQuery notifications, alias information will not be injected and\n * those fields will be ''.\n *\n * Note: Developers should note that only mediaChange activations (not de-activations)\n *       are announced by the MediaObserver.\n *\n *  @usage\n *\n *  // RxJS\n *  import { filter } from 'rxjs/operators';\n *  import { MediaObserver } from '@angular/flex-layout';\n *\n *  @Component({ ... })\n *  export class AppComponent {\n *    status: string = '';\n *\n *    constructor(mediaObserver: MediaObserver) {\n *      const media$ = mediaObserver.asObservable().pipe(\n *        filter((changes: MediaChange[]) => true)   // silly noop filter\n *      );\n *\n *      media$.subscribe((changes: MediaChange[]) => {\n *        let status = '';\n *        changes.forEach( change => {\n *          status += `'${change.mqAlias}' = (${change.mediaQuery}) <br/>` ;\n *        });\n *        this.status = status;\n *     });\n *\n *    }\n *  }\n */\n\n\nvar MediaObserver = /*#__PURE__*/(function () {\n  var MediaObserver = /*#__PURE__*/function () {\n    function MediaObserver(breakpoints, matchMedia, hook) {\n      _classCallCheck(this, MediaObserver);\n\n      this.breakpoints = breakpoints;\n      this.matchMedia = matchMedia;\n      this.hook = hook;\n      /** Filter MediaChange notifications for overlapping breakpoints */\n\n      this.filterOverlaps = false;\n      this.destroyed$ = new Subject();\n      this._media$ = this.watchActivations();\n      this.media$ = this._media$.pipe(filter(function (changes) {\n        return changes.length > 0;\n      }), map(function (changes) {\n        return changes[0];\n      }));\n    }\n    /**\n     * Completes the active subject, signalling to all complete for all\n     * MediaObserver subscribers\n     */\n\n\n    _createClass(MediaObserver, [{\n      key: \"ngOnDestroy\",\n      value: function ngOnDestroy() {\n        this.destroyed$.next();\n        this.destroyed$.complete();\n      } // ************************************************\n      // Public Methods\n      // ************************************************\n\n      /**\n       * Observe changes to current activation 'list'\n       */\n\n    }, {\n      key: \"asObservable\",\n      value: function asObservable() {\n        return this._media$;\n      }\n      /**\n       * Allow programmatic query to determine if one or more media query/alias match\n       * the current viewport size.\n       * @param value One or more media queries (or aliases) to check.\n       * @returns Whether any of the media queries match.\n       */\n\n    }, {\n      key: \"isActive\",\n      value: function isActive(value) {\n        var _this20 = this;\n\n        var aliases = splitQueries(coerceArray(value));\n        return aliases.some(function (alias) {\n          var query = toMediaQuery(alias, _this20.breakpoints);\n          return query !== null && _this20.matchMedia.isActive(query);\n        });\n      } // ************************************************\n      // Internal Methods\n      // ************************************************\n\n      /**\n       * Register all the mediaQueries registered in the BreakPointRegistry\n       * This is needed so subscribers can be auto-notified of all standard, registered\n       * mediaQuery activations\n       */\n\n    }, {\n      key: \"watchActivations\",\n      value: function watchActivations() {\n        var queries = this.breakpoints.items.map(function (bp) {\n          return bp.mediaQuery;\n        });\n        return this.buildObservable(queries);\n      }\n      /**\n       * Only pass/announce activations (not de-activations)\n       *\n       * Since multiple-mediaQueries can be activation in a cycle,\n       * gather all current activations into a single list of changes to observers\n       *\n       * Inject associated (if any) alias information into the MediaChange event\n       * - Exclude mediaQuery activations for overlapping mQs. List bounded mQ ranges only\n       * - Exclude print activations that do not have an associated mediaQuery\n       *\n       * NOTE: the raw MediaChange events [from MatchMedia] do not\n       *       contain important alias information; as such this info\n       *       must be injected into the MediaChange\n       */\n\n    }, {\n      key: \"buildObservable\",\n      value: function buildObservable(mqList) {\n        var _this21 = this;\n\n        var hasChanges = function hasChanges(changes) {\n          var isValidQuery = function isValidQuery(change) {\n            return change.mediaQuery.length > 0;\n          };\n\n          return changes.filter(isValidQuery).length > 0;\n        };\n\n        var excludeOverlaps = function excludeOverlaps(changes) {\n          return !_this21.filterOverlaps ? changes : changes.filter(function (change) {\n            var bp = _this21.breakpoints.findByQuery(change.mediaQuery);\n\n            return !bp ? true : !bp.overlapping;\n          });\n        };\n        /**\n         */\n\n\n        return this.matchMedia.observe(this.hook.withPrintQuery(mqList)).pipe(filter(function (change) {\n          return change.matches;\n        }), debounceTime(0, asapScheduler), switchMap(function (_) {\n          return of(_this21.findAllActivations());\n        }), map(excludeOverlaps), filter(hasChanges), takeUntil(this.destroyed$));\n      }\n      /**\n       * Find all current activations and prepare single list of activations\n       * sorted by descending priority.\n       */\n\n    }, {\n      key: \"findAllActivations\",\n      value: function findAllActivations() {\n        var _this22 = this;\n\n        var mergeMQAlias = function mergeMQAlias(change) {\n          var bp = _this22.breakpoints.findByQuery(change.mediaQuery);\n\n          return mergeAlias(change, bp);\n        };\n\n        var replaceWithPrintAlias = function replaceWithPrintAlias(change) {\n          return _this22.hook.isPrintEvent(change) ? _this22.hook.updateEvent(change) : change;\n        };\n\n        return this.matchMedia.activations.map(function (query) {\n          return new MediaChange(true, query);\n        }).map(replaceWithPrintAlias).map(mergeMQAlias).sort(sortDescendingPriority);\n      }\n    }]);\n\n    return MediaObserver;\n  }();\n\n  MediaObserver.ɵfac = function MediaObserver_Factory(t) {\n    return new (t || MediaObserver)(i0.ɵɵinject(BreakPointRegistry), i0.ɵɵinject(MatchMedia), i0.ɵɵinject(PrintHook));\n  };\n\n  MediaObserver.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: MediaObserver,\n    factory: MediaObserver.ɵfac,\n    providedIn: 'root'\n  });\n  return MediaObserver;\n})();\n\n/*#__PURE__*/\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Find associated breakpoint (if any)\n */\n\n\nfunction toMediaQuery(query, locator) {\n  var bp = locator.findByAlias(query) || locator.findByQuery(query);\n  return bp ? bp.mediaQuery : null;\n}\n/**\n * Split each query string into separate query strings if two queries are provided as comma\n * separated.\n */\n\n\nfunction splitQueries(queries) {\n  return queries.map(function (query) {\n    return query.split(',');\n  }).reduce(function (a1, a2) {\n    return a1.concat(a2);\n  }).map(function (query) {\n    return query.trim();\n  });\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Class\n */\n\n\nvar MediaTrigger = /*#__PURE__*/(function () {\n  var MediaTrigger = /*#__PURE__*/function () {\n    function MediaTrigger(breakpoints, matchMedia, layoutConfig, _platformId, _document) {\n      _classCallCheck(this, MediaTrigger);\n\n      this.breakpoints = breakpoints;\n      this.matchMedia = matchMedia;\n      this.layoutConfig = layoutConfig;\n      this._platformId = _platformId;\n      this._document = _document;\n      this.hasCachedRegistryMatches = false;\n      this.originalActivations = [];\n      this.originalRegistry = new Map();\n    }\n    /**\n     * Manually activate range of breakpoints\n     * @param list array of mediaQuery or alias strings\n     */\n\n\n    _createClass(MediaTrigger, [{\n      key: \"activate\",\n      value: function activate(list) {\n        list = list.map(function (it) {\n          return it.trim();\n        }); // trim queries\n\n        this.saveActivations();\n        this.deactivateAll();\n        this.setActivations(list);\n        this.prepareAutoRestore();\n      }\n      /**\n       * Restore original, 'real' breakpoints and emit events\n       * to trigger stream notification\n       */\n\n    }, {\n      key: \"restore\",\n      value: function restore() {\n        if (this.hasCachedRegistryMatches) {\n          var extractQuery = function extractQuery(change) {\n            return change.mediaQuery;\n          };\n\n          var list = this.originalActivations.map(extractQuery);\n\n          try {\n            this.deactivateAll();\n            this.restoreRegistryMatches();\n            this.setActivations(list);\n          } finally {\n            this.originalActivations = [];\n\n            if (this.resizeSubscription) {\n              this.resizeSubscription.unsubscribe();\n            }\n          }\n        }\n      } // ************************************************\n      // Internal Methods\n      // ************************************************\n\n      /**\n       * Whenever window resizes, immediately auto-restore original\n       * activations (if we are simulating activations)\n       */\n\n    }, {\n      key: \"prepareAutoRestore\",\n      value: function prepareAutoRestore() {\n        var isBrowser = isPlatformBrowser(this._platformId) && this._document;\n\n        var enableAutoRestore = isBrowser && this.layoutConfig.mediaTriggerAutoRestore;\n\n        if (enableAutoRestore) {\n          var resize$ = fromEvent(window, 'resize').pipe(take(1));\n          this.resizeSubscription = resize$.subscribe(this.restore.bind(this));\n        }\n      }\n      /**\n       * Notify all matchMedia subscribers of de-activations\n       *\n       * Note: we must force 'matches' updates for\n       *       future matchMedia::activation lookups\n       */\n\n    }, {\n      key: \"deactivateAll\",\n      value: function deactivateAll() {\n        var list = this.currentActivations;\n        this.forceRegistryMatches(list, false);\n        this.simulateMediaChanges(list, false);\n      }\n      /**\n       * Cache current activations as sorted, prioritized list of MediaChanges\n       */\n\n    }, {\n      key: \"saveActivations\",\n      value: function saveActivations() {\n        var _this23 = this;\n\n        if (!this.hasCachedRegistryMatches) {\n          var toMediaChange = function toMediaChange(query) {\n            return new MediaChange(true, query);\n          };\n\n          var mergeMQAlias = function mergeMQAlias(change) {\n            var bp = _this23.breakpoints.findByQuery(change.mediaQuery);\n\n            return mergeAlias(change, bp);\n          };\n\n          this.originalActivations = this.currentActivations.map(toMediaChange).map(mergeMQAlias).sort(sortDescendingPriority);\n          this.cacheRegistryMatches();\n        }\n      }\n      /**\n       * Force set manual activations for specified mediaQuery list\n       */\n\n    }, {\n      key: \"setActivations\",\n      value: function setActivations(list) {\n        if (!!this.originalRegistry) {\n          this.forceRegistryMatches(list, true);\n        }\n\n        this.simulateMediaChanges(list);\n      }\n      /**\n       * For specified mediaQuery list manually simulate activations or deactivations\n       */\n\n    }, {\n      key: \"simulateMediaChanges\",\n      value: function simulateMediaChanges(queries) {\n        var _this24 = this;\n\n        var matches = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n        var toMediaQuery = function toMediaQuery(query) {\n          var locator = _this24.breakpoints;\n          var bp = locator.findByAlias(query) || locator.findByQuery(query);\n          return bp ? bp.mediaQuery : query;\n        };\n\n        var emitChangeEvent = function emitChangeEvent(query) {\n          return _this24.emitChangeEvent(matches, query);\n        };\n\n        queries.map(toMediaQuery).forEach(emitChangeEvent);\n      }\n      /**\n       * Replace current registry with simulated registry...\n       * Note: this is required since MediaQueryList::matches is 'readOnly'\n       */\n\n    }, {\n      key: \"forceRegistryMatches\",\n      value: function forceRegistryMatches(queries, matches) {\n        var registry = new Map();\n        queries.forEach(function (query) {\n          registry.set(query, {\n            matches: matches\n          });\n        });\n        this.matchMedia.registry = registry;\n      }\n      /**\n       * Save current MatchMedia::registry items.\n       */\n\n    }, {\n      key: \"cacheRegistryMatches\",\n      value: function cacheRegistryMatches() {\n        var target = this.originalRegistry;\n        target.clear();\n        this.matchMedia.registry.forEach(function (value, key) {\n          target.set(key, value);\n        });\n        this.hasCachedRegistryMatches = true;\n      }\n      /**\n       * Restore original, 'true' registry\n       */\n\n    }, {\n      key: \"restoreRegistryMatches\",\n      value: function restoreRegistryMatches() {\n        var target = this.matchMedia.registry;\n        target.clear();\n        this.originalRegistry.forEach(function (value, key) {\n          target.set(key, value);\n        });\n        this.originalRegistry.clear();\n        this.hasCachedRegistryMatches = false;\n      }\n      /**\n       * Manually emit a MediaChange event via the MatchMedia to MediaMarshaller and MediaObserver\n       */\n\n    }, {\n      key: \"emitChangeEvent\",\n      value: function emitChangeEvent(matches, query) {\n        this.matchMedia.source.next(new MediaChange(matches, query));\n      }\n    }, {\n      key: \"currentActivations\",\n      get: function get() {\n        return this.matchMedia.activations;\n      }\n    }]);\n\n    return MediaTrigger;\n  }();\n\n  MediaTrigger.ɵfac = function MediaTrigger_Factory(t) {\n    return new (t || MediaTrigger)(i0.ɵɵinject(BreakPointRegistry), i0.ɵɵinject(MatchMedia), i0.ɵɵinject(LAYOUT_CONFIG), i0.ɵɵinject(PLATFORM_ID), i0.ɵɵinject(DOCUMENT));\n  };\n\n  MediaTrigger.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: MediaTrigger,\n    factory: MediaTrigger.ɵfac,\n    providedIn: 'root'\n  });\n  return MediaTrigger;\n})();\n\n/*#__PURE__*/\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n* The flex API permits 3 or 1 parts of the value:\n*    - `flex-grow flex-shrink flex-basis`, or\n*    - `flex-basis`\n*/\n\n\nfunction validateBasis(basis) {\n  var grow = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '1';\n  var shrink = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '1';\n  var parts = [grow, shrink, basis];\n  var j = basis.indexOf('calc');\n\n  if (j > 0) {\n    parts[2] = _validateCalcValue(basis.substring(j).trim());\n    var matches = basis.substr(0, j).trim().split(' ');\n\n    if (matches.length == 2) {\n      parts[0] = matches[0];\n      parts[1] = matches[1];\n    }\n  } else if (j == 0) {\n    parts[2] = _validateCalcValue(basis.trim());\n  } else {\n    var _matches = basis.split(' ');\n\n    parts = _matches.length === 3 ? _matches : [grow, shrink, basis];\n  }\n\n  return parts;\n}\n/**\n * Calc expressions require whitespace before & after any expression operators\n * This is a simple, crude whitespace padding solution.\n *   - '3 3 calc(15em + 20px)'\n *   - calc(100% / 7 * 2)\n *   - 'calc(15em + 20px)'\n *   - 'calc(15em+20px)'\n *   - '37px'\n *   = '43%'\n */\n\n\nfunction _validateCalcValue(calc) {\n  return calc.replace(/[\\s]/g, '').replace(/[\\/\\*\\+\\-]/g, ' $& ');\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { BREAKPOINT, BREAKPOINTS, BREAKPOINT_PRINT, BROWSER_PROVIDER, BaseDirective2, BreakPointRegistry, CLASS_NAME, CoreModule, DEFAULT_BREAKPOINTS, DEFAULT_CONFIG, LAYOUT_CONFIG, MediaChange, MediaMarshaller, MediaObserver, MediaTrigger, ORIENTATION_BREAKPOINTS, PrintHook, SERVER_TOKEN, ScreenTypes, StyleBuilder, StyleUtils, StylesheetMap, coerceArray, mergeAlias, removeStyles, sortAscendingPriority, sortDescendingPriority, validateBasis, MatchMedia as ɵMatchMedia, MockMatchMedia as ɵMockMatchMedia, MockMatchMediaProvider as ɵMockMatchMediaProvider }; //# sourceMappingURL=angular-flex-layout-core.mjs.map","map":null,"metadata":{},"sourceType":"module"}