{"ast":null,"code":"import _createForOfIteratorHelper from \"/Applications/MAMP/htdocs/memberhive/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _toArray from \"/Applications/MAMP/htdocs/memberhive/node_modules/@babel/runtime/helpers/esm/toArray.js\";\nimport _slicedToArray from \"/Applications/MAMP/htdocs/memberhive/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _toConsumableArray from \"/Applications/MAMP/htdocs/memberhive/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _defineProperty from \"/Applications/MAMP/htdocs/memberhive/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport _classCallCheck from \"/Applications/MAMP/htdocs/memberhive/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Applications/MAMP/htdocs/memberhive/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _get from \"/Applications/MAMP/htdocs/memberhive/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"/Applications/MAMP/htdocs/memberhive/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _inherits from \"/Applications/MAMP/htdocs/memberhive/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Applications/MAMP/htdocs/memberhive/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport * as i0 from '@angular/core';\nimport { Injectable, InjectionToken, Inject, isDevMode, NgModule, Optional, SkipSelf, Injector } from '@angular/core';\nimport { BehaviorSubject, Observable, Subject, queueScheduler } from 'rxjs';\nimport { observeOn, withLatestFrom, scan, pluck, map, distinctUntilChanged } from 'rxjs/operators';\nvar REGISTERED_ACTION_TYPES = {};\n\nfunction resetRegisteredActionTypes() {\n  for (var _i = 0, _Object$keys = Object.keys(REGISTERED_ACTION_TYPES); _i < _Object$keys.length; _i++) {\n    var key = _Object$keys[_i];\n    delete REGISTERED_ACTION_TYPES[key];\n  }\n}\n/**\n * @description\n * Creates a configured `Creator` function that, when called, returns an object in the shape of the `Action` interface.\n *\n * Action creators reduce the explicitness of class-based action creators.\n *\n * @param type Describes the action that will be dispatched\n * @param config Additional metadata needed for the handling of the action.  See {@link createAction#usage-notes Usage Notes}.\n *\n * @usageNotes\n *\n * **Declaring an action creator**\n *\n * Without additional metadata:\n * ```ts\n * export const increment = createAction('[Counter] Increment');\n * ```\n * With additional metadata:\n * ```ts\n * export const loginSuccess = createAction(\n *   '[Auth/API] Login Success',\n *   props<{ user: User }>()\n * );\n * ```\n * With a function:\n * ```ts\n * export const loginSuccess = createAction(\n *   '[Auth/API] Login Success',\n *   (response: Response) => response.user\n * );\n * ```\n *\n * **Dispatching an action**\n *\n * Without additional metadata:\n * ```ts\n * store.dispatch(increment());\n * ```\n * With additional metadata:\n * ```ts\n * store.dispatch(loginSuccess({ user: newUser }));\n * ```\n *\n * **Referencing an action in a reducer**\n *\n * Using a switch statement:\n * ```ts\n * switch (action.type) {\n *   // ...\n *   case AuthApiActions.loginSuccess.type: {\n *     return {\n *       ...state,\n *       user: action.user\n *     };\n *   }\n * }\n * ```\n * Using a reducer creator:\n * ```ts\n * on(AuthApiActions.loginSuccess, (state, { user }) => ({ ...state, user }))\n * ```\n *\n *  **Referencing an action in an effect**\n * ```ts\n * effectName$ = createEffect(\n *   () => this.actions$.pipe(\n *     ofType(AuthApiActions.loginSuccess),\n *     // ...\n *   )\n * );\n * ```\n */\n\n\nfunction createAction(type, config) {\n  REGISTERED_ACTION_TYPES[type] = (REGISTERED_ACTION_TYPES[type] || 0) + 1;\n\n  if (typeof config === 'function') {\n    return defineType(type, function () {\n      return Object.assign(Object.assign({}, config.apply(void 0, arguments)), {\n        type: type\n      });\n    });\n  }\n\n  var as = config ? config._as : 'empty';\n\n  switch (as) {\n    case 'empty':\n      return defineType(type, function () {\n        return {\n          type: type\n        };\n      });\n\n    case 'props':\n      return defineType(type, function (props) {\n        return Object.assign(Object.assign({}, props), {\n          type: type\n        });\n      });\n\n    default:\n      throw new Error('Unexpected config.');\n  }\n}\n\nfunction props() {\n  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion, @typescript-eslint/naming-convention\n  return {\n    _as: 'props',\n    _p: undefined\n  };\n}\n\nfunction union(creators) {\n  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n  return undefined;\n}\n\nfunction defineType(type, creator) {\n  return Object.defineProperty(creator, 'type', {\n    value: type,\n    writable: false\n  });\n}\n\nvar INIT = '@ngrx/store/init';\nvar ActionsSubject = /*#__PURE__*/(function () {\n  var ActionsSubject = /*#__PURE__*/function (_BehaviorSubject) {\n    _inherits(ActionsSubject, _BehaviorSubject);\n\n    var _super = _createSuper(ActionsSubject);\n\n    function ActionsSubject() {\n      _classCallCheck(this, ActionsSubject);\n\n      return _super.call(this, {\n        type: INIT\n      });\n    }\n\n    _createClass(ActionsSubject, [{\n      key: \"next\",\n      value: function next(action) {\n        if (typeof action === 'function') {\n          throw new TypeError(\"\\n        Dispatch expected an object, instead it received a function.\\n        If you're using the createAction function, make sure to invoke the function\\n        before dispatching the action. For example, someAction should be someAction().\");\n        } else if (typeof action === 'undefined') {\n          throw new TypeError(\"Actions must be objects\");\n        } else if (typeof action.type === 'undefined') {\n          throw new TypeError(\"Actions must have a type property\");\n        }\n\n        _get(_getPrototypeOf(ActionsSubject.prototype), \"next\", this).call(this, action);\n      }\n    }, {\n      key: \"complete\",\n      value: function complete() {\n        /* noop */\n      }\n    }, {\n      key: \"ngOnDestroy\",\n      value: function ngOnDestroy() {\n        _get(_getPrototypeOf(ActionsSubject.prototype), \"complete\", this).call(this);\n      }\n    }]);\n\n    return ActionsSubject;\n  }(BehaviorSubject);\n\n  /** @nocollapse */\n\n  /** @nocollapse */\n  ActionsSubject.ɵfac = function ActionsSubject_Factory(t) {\n    return new (t || ActionsSubject)();\n  };\n  /** @nocollapse */\n\n  /** @nocollapse */\n\n\n  ActionsSubject.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: ActionsSubject,\n    factory: ActionsSubject.ɵfac\n  });\n  return ActionsSubject;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nvar ACTIONS_SUBJECT_PROVIDERS = [ActionsSubject];\n\nvar _ROOT_STORE_GUARD = new InjectionToken('@ngrx/store Internal Root Guard');\n\nvar _INITIAL_STATE = new InjectionToken('@ngrx/store Internal Initial State');\n\nvar INITIAL_STATE = new InjectionToken('@ngrx/store Initial State');\nvar REDUCER_FACTORY = new InjectionToken('@ngrx/store Reducer Factory');\n\nvar _REDUCER_FACTORY = new InjectionToken('@ngrx/store Internal Reducer Factory Provider');\n\nvar INITIAL_REDUCERS = new InjectionToken('@ngrx/store Initial Reducers');\n\nvar _INITIAL_REDUCERS = new InjectionToken('@ngrx/store Internal Initial Reducers');\n\nvar STORE_FEATURES = new InjectionToken('@ngrx/store Store Features');\n\nvar _STORE_REDUCERS = new InjectionToken('@ngrx/store Internal Store Reducers');\n\nvar _FEATURE_REDUCERS = new InjectionToken('@ngrx/store Internal Feature Reducers');\n\nvar _FEATURE_CONFIGS = new InjectionToken('@ngrx/store Internal Feature Configs');\n\nvar _STORE_FEATURES = new InjectionToken('@ngrx/store Internal Store Features');\n\nvar _FEATURE_REDUCERS_TOKEN = new InjectionToken('@ngrx/store Internal Feature Reducers Token');\n\nvar FEATURE_REDUCERS = new InjectionToken('@ngrx/store Feature Reducers');\n/**\n * User-defined meta reducers from StoreModule.forRoot()\n */\n\nvar USER_PROVIDED_META_REDUCERS = new InjectionToken('@ngrx/store User Provided Meta Reducers');\n/**\n * Meta reducers defined either internally by @ngrx/store or by library authors\n */\n\nvar META_REDUCERS = new InjectionToken('@ngrx/store Meta Reducers');\n/**\n * Concats the user provided meta reducers and the meta reducers provided on the multi\n * injection token\n */\n\nvar _RESOLVED_META_REDUCERS = new InjectionToken('@ngrx/store Internal Resolved Meta Reducers');\n/**\n * Runtime checks defined by the user via an InjectionToken\n * Defaults to `_USER_RUNTIME_CHECKS`\n */\n\n\nvar USER_RUNTIME_CHECKS = new InjectionToken('@ngrx/store User Runtime Checks Config');\n/**\n * Runtime checks defined by the user via forRoot()\n */\n\nvar _USER_RUNTIME_CHECKS = new InjectionToken('@ngrx/store Internal User Runtime Checks Config');\n/**\n * Runtime checks currently in use\n */\n\n\nvar ACTIVE_RUNTIME_CHECKS = new InjectionToken('@ngrx/store Internal Runtime Checks');\n\nvar _ACTION_TYPE_UNIQUENESS_CHECK = new InjectionToken('@ngrx/store Check if Action types are unique');\n/**\n * @description\n * Combines reducers for individual features into a single reducer.\n *\n * You can use this function to delegate handling of state transitions to multiple reducers, each acting on their\n * own sub-state within the root state.\n *\n * @param reducers An object mapping keys of the root state to their corresponding feature reducer.\n * @param initialState Provides a state value if the current state is `undefined`, as it is initially.\n * @returns A reducer function.\n *\n * @usageNotes\n *\n * **Example combining two feature reducers into one \"root\" reducer**\n *\n * ```ts\n * export const reducer = combineReducers({\n *   featureA: featureAReducer,\n *   featureB: featureBReducer\n * });\n * ```\n *\n * You can also override the initial states of the sub-features:\n * ```ts\n * export const reducer = combineReducers({\n *   featureA: featureAReducer,\n *   featureB: featureBReducer\n * }, {\n *   featureA: { counterA: 13 },\n *   featureB: { counterB: 37 }\n * });\n * ```\n */\n\n\nfunction combineReducers(reducers) {\n  var initialState = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var reducerKeys = Object.keys(reducers);\n  var finalReducers = {};\n\n  for (var i = 0; i < reducerKeys.length; i++) {\n    var key = reducerKeys[i];\n\n    if (typeof reducers[key] === 'function') {\n      finalReducers[key] = reducers[key];\n    }\n  }\n\n  var finalReducerKeys = Object.keys(finalReducers);\n  return function combination(state, action) {\n    state = state === undefined ? initialState : state;\n    var hasChanged = false;\n    var nextState = {};\n\n    for (var _i2 = 0; _i2 < finalReducerKeys.length; _i2++) {\n      var _key = finalReducerKeys[_i2];\n      var reducer = finalReducers[_key];\n      var previousStateForKey = state[_key];\n      var nextStateForKey = reducer(previousStateForKey, action);\n      nextState[_key] = nextStateForKey;\n      hasChanged = hasChanged || nextStateForKey !== previousStateForKey;\n    }\n\n    return hasChanged ? nextState : state;\n  };\n}\n\nfunction omit(object, keyToRemove) {\n  return Object.keys(object).filter(function (key) {\n    return key !== keyToRemove;\n  }).reduce(function (result, key) {\n    return Object.assign(result, _defineProperty({}, key, object[key]));\n  }, {});\n}\n\nfunction compose() {\n  for (var _len = arguments.length, functions = new Array(_len), _key2 = 0; _key2 < _len; _key2++) {\n    functions[_key2] = arguments[_key2];\n  }\n\n  return function (arg) {\n    if (functions.length === 0) {\n      return arg;\n    }\n\n    var last = functions[functions.length - 1];\n    var rest = functions.slice(0, -1);\n    return rest.reduceRight(function (composed, fn) {\n      return fn(composed);\n    }, last(arg));\n  };\n}\n\nfunction createReducerFactory(reducerFactory, metaReducers) {\n  if (Array.isArray(metaReducers) && metaReducers.length > 0) {\n    reducerFactory = compose.apply(null, [].concat(_toConsumableArray(metaReducers), [reducerFactory]));\n  }\n\n  return function (reducers, initialState) {\n    var reducer = reducerFactory(reducers);\n    return function (state, action) {\n      state = state === undefined ? initialState : state;\n      return reducer(state, action);\n    };\n  };\n}\n\nfunction createFeatureReducerFactory(metaReducers) {\n  var reducerFactory = Array.isArray(metaReducers) && metaReducers.length > 0 ? compose.apply(void 0, _toConsumableArray(metaReducers)) : function (r) {\n    return r;\n  };\n  return function (reducer, initialState) {\n    reducer = reducerFactory(reducer);\n    return function (state, action) {\n      state = state === undefined ? initialState : state;\n      return reducer(state, action);\n    };\n  };\n}\n\nvar ReducerObservable = /*#__PURE__*/function (_Observable) {\n  _inherits(ReducerObservable, _Observable);\n\n  var _super2 = _createSuper(ReducerObservable);\n\n  function ReducerObservable() {\n    _classCallCheck(this, ReducerObservable);\n\n    return _super2.apply(this, arguments);\n  }\n\n  return _createClass(ReducerObservable);\n}(Observable);\n\nvar ReducerManagerDispatcher = /*#__PURE__*/function (_ActionsSubject) {\n  _inherits(ReducerManagerDispatcher, _ActionsSubject);\n\n  var _super3 = _createSuper(ReducerManagerDispatcher);\n\n  function ReducerManagerDispatcher() {\n    _classCallCheck(this, ReducerManagerDispatcher);\n\n    return _super3.apply(this, arguments);\n  }\n\n  return _createClass(ReducerManagerDispatcher);\n}(ActionsSubject);\n\nvar UPDATE = '@ngrx/store/update-reducers';\nvar ReducerManager = /*#__PURE__*/(function () {\n  var ReducerManager = /*#__PURE__*/function (_BehaviorSubject2) {\n    _inherits(ReducerManager, _BehaviorSubject2);\n\n    var _super4 = _createSuper(ReducerManager);\n\n    function ReducerManager(dispatcher, initialState, reducers, reducerFactory) {\n      var _this;\n\n      _classCallCheck(this, ReducerManager);\n\n      _this = _super4.call(this, reducerFactory(reducers, initialState));\n      _this.dispatcher = dispatcher;\n      _this.initialState = initialState;\n      _this.reducers = reducers;\n      _this.reducerFactory = reducerFactory;\n      return _this;\n    }\n\n    _createClass(ReducerManager, [{\n      key: \"currentReducers\",\n      get: function get() {\n        return this.reducers;\n      }\n    }, {\n      key: \"addFeature\",\n      value: function addFeature(feature) {\n        this.addFeatures([feature]);\n      }\n    }, {\n      key: \"addFeatures\",\n      value: function addFeatures(features) {\n        var reducers = features.reduce(function (reducerDict, _ref) {\n          var reducers = _ref.reducers,\n              reducerFactory = _ref.reducerFactory,\n              metaReducers = _ref.metaReducers,\n              initialState = _ref.initialState,\n              key = _ref.key;\n          var reducer = typeof reducers === 'function' ? createFeatureReducerFactory(metaReducers)(reducers, initialState) : createReducerFactory(reducerFactory, metaReducers)(reducers, initialState);\n          reducerDict[key] = reducer;\n          return reducerDict;\n        }, {});\n        this.addReducers(reducers);\n      }\n    }, {\n      key: \"removeFeature\",\n      value: function removeFeature(feature) {\n        this.removeFeatures([feature]);\n      }\n    }, {\n      key: \"removeFeatures\",\n      value: function removeFeatures(features) {\n        this.removeReducers(features.map(function (p) {\n          return p.key;\n        }));\n      }\n    }, {\n      key: \"addReducer\",\n      value: function addReducer(key, reducer) {\n        this.addReducers(_defineProperty({}, key, reducer));\n      }\n    }, {\n      key: \"addReducers\",\n      value: function addReducers(reducers) {\n        this.reducers = Object.assign(Object.assign({}, this.reducers), reducers);\n        this.updateReducers(Object.keys(reducers));\n      }\n    }, {\n      key: \"removeReducer\",\n      value: function removeReducer(featureKey) {\n        this.removeReducers([featureKey]);\n      }\n    }, {\n      key: \"removeReducers\",\n      value: function removeReducers(featureKeys) {\n        var _this2 = this;\n\n        featureKeys.forEach(function (key) {\n          _this2.reducers = omit(_this2.reducers, key)\n          /*TODO(#823)*/\n          ;\n        });\n        this.updateReducers(featureKeys);\n      }\n    }, {\n      key: \"updateReducers\",\n      value: function updateReducers(featureKeys) {\n        this.next(this.reducerFactory(this.reducers, this.initialState));\n        this.dispatcher.next({\n          type: UPDATE,\n          features: featureKeys\n        });\n      }\n    }, {\n      key: \"ngOnDestroy\",\n      value: function ngOnDestroy() {\n        this.complete();\n      }\n    }]);\n\n    return ReducerManager;\n  }(BehaviorSubject);\n\n  /** @nocollapse */\n\n  /** @nocollapse */\n  ReducerManager.ɵfac = function ReducerManager_Factory(t) {\n    return new (t || ReducerManager)(i0.ɵɵinject(ReducerManagerDispatcher), i0.ɵɵinject(INITIAL_STATE), i0.ɵɵinject(INITIAL_REDUCERS), i0.ɵɵinject(REDUCER_FACTORY));\n  };\n  /** @nocollapse */\n\n  /** @nocollapse */\n\n\n  ReducerManager.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: ReducerManager,\n    factory: ReducerManager.ɵfac\n  });\n  return ReducerManager;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nvar REDUCER_MANAGER_PROVIDERS = [ReducerManager, {\n  provide: ReducerObservable,\n  useExisting: ReducerManager\n}, {\n  provide: ReducerManagerDispatcher,\n  useExisting: ActionsSubject\n}];\nvar ScannedActionsSubject = /*#__PURE__*/(function () {\n  var ScannedActionsSubject = /*#__PURE__*/function (_Subject) {\n    _inherits(ScannedActionsSubject, _Subject);\n\n    var _super5 = _createSuper(ScannedActionsSubject);\n\n    function ScannedActionsSubject() {\n      _classCallCheck(this, ScannedActionsSubject);\n\n      return _super5.apply(this, arguments);\n    }\n\n    _createClass(ScannedActionsSubject, [{\n      key: \"ngOnDestroy\",\n      value: function ngOnDestroy() {\n        this.complete();\n      }\n    }]);\n\n    return ScannedActionsSubject;\n  }(Subject);\n\n  /** @nocollapse */\n\n  /** @nocollapse */\n  ScannedActionsSubject.ɵfac = /* @__PURE__ */function () {\n    var ɵScannedActionsSubject_BaseFactory;\n    return function ScannedActionsSubject_Factory(t) {\n      return (ɵScannedActionsSubject_BaseFactory || (ɵScannedActionsSubject_BaseFactory = i0.ɵɵgetInheritedFactory(ScannedActionsSubject)))(t || ScannedActionsSubject);\n    };\n  }();\n  /** @nocollapse */\n\n  /** @nocollapse */\n\n\n  ScannedActionsSubject.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: ScannedActionsSubject,\n    factory: ScannedActionsSubject.ɵfac\n  });\n  return ScannedActionsSubject;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nvar SCANNED_ACTIONS_SUBJECT_PROVIDERS = [ScannedActionsSubject];\n\nvar StateObservable = /*#__PURE__*/function (_Observable2) {\n  _inherits(StateObservable, _Observable2);\n\n  var _super6 = _createSuper(StateObservable);\n\n  function StateObservable() {\n    _classCallCheck(this, StateObservable);\n\n    return _super6.apply(this, arguments);\n  }\n\n  return _createClass(StateObservable);\n}(Observable);\n\nvar State = /*#__PURE__*/(function () {\n  var State = /*#__PURE__*/function (_BehaviorSubject3) {\n    _inherits(State, _BehaviorSubject3);\n\n    var _super7 = _createSuper(State);\n\n    function State(actions$, reducer$, scannedActions, initialState) {\n      var _this3;\n\n      _classCallCheck(this, State);\n\n      _this3 = _super7.call(this, initialState);\n      var actionsOnQueue$ = actions$.pipe(observeOn(queueScheduler));\n      var withLatestReducer$ = actionsOnQueue$.pipe(withLatestFrom(reducer$));\n      var seed = {\n        state: initialState\n      };\n      var stateAndAction$ = withLatestReducer$.pipe(scan(reduceState, seed));\n      _this3.stateSubscription = stateAndAction$.subscribe(function (_ref2) {\n        var state = _ref2.state,\n            action = _ref2.action;\n\n        _this3.next(state);\n\n        scannedActions.next(action);\n      });\n      return _this3;\n    }\n\n    _createClass(State, [{\n      key: \"ngOnDestroy\",\n      value: function ngOnDestroy() {\n        this.stateSubscription.unsubscribe();\n        this.complete();\n      }\n    }]);\n\n    return State;\n  }(BehaviorSubject);\n\n  State.INIT = INIT;\n  /** @nocollapse */\n\n  /** @nocollapse */\n\n  State.ɵfac = function State_Factory(t) {\n    return new (t || State)(i0.ɵɵinject(ActionsSubject), i0.ɵɵinject(ReducerObservable), i0.ɵɵinject(ScannedActionsSubject), i0.ɵɵinject(INITIAL_STATE));\n  };\n  /** @nocollapse */\n\n  /** @nocollapse */\n\n\n  State.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: State,\n    factory: State.ɵfac\n  });\n  return State;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nfunction reduceState() {\n  var stateActionPair = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n    state: undefined\n  };\n\n  var _ref3 = arguments.length > 1 ? arguments[1] : undefined,\n      _ref4 = _slicedToArray(_ref3, 2),\n      action = _ref4[0],\n      reducer = _ref4[1];\n\n  var state = stateActionPair.state;\n  return {\n    state: reducer(state, action),\n    action: action\n  };\n}\n\nvar STATE_PROVIDERS = [State, {\n  provide: StateObservable,\n  useExisting: State\n}];\n/* eslint-disable @typescript-eslint/naming-convention */\n\nvar Store = /*#__PURE__*/(function () {\n  var Store = /*#__PURE__*/function (_Observable3) {\n    _inherits(Store, _Observable3);\n\n    var _super8 = _createSuper(Store);\n\n    function Store(state$, actionsObserver, reducerManager) {\n      var _this4;\n\n      _classCallCheck(this, Store);\n\n      _this4 = _super8.call(this);\n      _this4.actionsObserver = actionsObserver;\n      _this4.reducerManager = reducerManager;\n      _this4.source = state$;\n      return _this4;\n    }\n\n    _createClass(Store, [{\n      key: \"select\",\n      value: function select(pathOrMapFn) {\n        for (var _len2 = arguments.length, paths = new Array(_len2 > 1 ? _len2 - 1 : 0), _key3 = 1; _key3 < _len2; _key3++) {\n          paths[_key3 - 1] = arguments[_key3];\n        }\n\n        return _select.call.apply(_select, [null, pathOrMapFn].concat(paths))(this);\n      }\n    }, {\n      key: \"lift\",\n      value: function lift(operator) {\n        var store = new Store(this, this.actionsObserver, this.reducerManager);\n        store.operator = operator;\n        return store;\n      }\n    }, {\n      key: \"dispatch\",\n      value: function dispatch(action) {\n        this.actionsObserver.next(action);\n      }\n    }, {\n      key: \"next\",\n      value: function next(action) {\n        this.actionsObserver.next(action);\n      }\n    }, {\n      key: \"error\",\n      value: function error(err) {\n        this.actionsObserver.error(err);\n      }\n    }, {\n      key: \"complete\",\n      value: function complete() {\n        this.actionsObserver.complete();\n      }\n    }, {\n      key: \"addReducer\",\n      value: function addReducer(key, reducer) {\n        this.reducerManager.addReducer(key, reducer);\n      }\n    }, {\n      key: \"removeReducer\",\n      value: function removeReducer(key) {\n        this.reducerManager.removeReducer(key);\n      }\n    }]);\n\n    return Store;\n  }(Observable);\n\n  /** @nocollapse */\n\n  /** @nocollapse */\n  Store.ɵfac = function Store_Factory(t) {\n    return new (t || Store)(i0.ɵɵinject(StateObservable), i0.ɵɵinject(ActionsSubject), i0.ɵɵinject(ReducerManager));\n  };\n  /** @nocollapse */\n\n  /** @nocollapse */\n\n\n  Store.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: Store,\n    factory: Store.ɵfac\n  });\n  return Store;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nvar STORE_PROVIDERS = [Store];\n\nfunction _select(pathOrMapFn, propsOrPath) {\n  for (var _len3 = arguments.length, paths = new Array(_len3 > 2 ? _len3 - 2 : 0), _key4 = 2; _key4 < _len3; _key4++) {\n    paths[_key4 - 2] = arguments[_key4];\n  }\n\n  return function selectOperator(source$) {\n    var mapped$;\n\n    if (typeof pathOrMapFn === 'string') {\n      var pathSlices = [propsOrPath].concat(paths).filter(Boolean);\n      mapped$ = source$.pipe(pluck.apply(void 0, [pathOrMapFn].concat(_toConsumableArray(pathSlices))));\n    } else if (typeof pathOrMapFn === 'function') {\n      mapped$ = source$.pipe(map(function (source) {\n        return pathOrMapFn(source, propsOrPath);\n      }));\n    } else {\n      throw new TypeError(\"Unexpected type '\".concat(typeof pathOrMapFn, \"' in select operator,\") + \" expected 'string' or 'function'\");\n    }\n\n    return mapped$.pipe(distinctUntilChanged());\n  };\n}\n\nfunction capitalize(text) {\n  return text.charAt(0).toUpperCase() + text.substr(1);\n}\n\nvar RUNTIME_CHECK_URL = 'https://ngrx.io/guide/store/configuration/runtime-checks';\n\nfunction isUndefined(target) {\n  return target === undefined;\n}\n\nfunction isNull(target) {\n  return target === null;\n}\n\nfunction isArray(target) {\n  return Array.isArray(target);\n}\n\nfunction isString(target) {\n  return typeof target === 'string';\n}\n\nfunction isBoolean(target) {\n  return typeof target === 'boolean';\n}\n\nfunction isNumber(target) {\n  return typeof target === 'number';\n}\n\nfunction isObjectLike(target) {\n  return typeof target === 'object' && target !== null;\n}\n\nfunction isObject(target) {\n  return isObjectLike(target) && !isArray(target);\n}\n\nfunction isPlainObject(target) {\n  if (!isObject(target)) {\n    return false;\n  }\n\n  var targetPrototype = Object.getPrototypeOf(target);\n  return targetPrototype === Object.prototype || targetPrototype === null;\n}\n\nfunction isFunction(target) {\n  return typeof target === 'function';\n}\n\nfunction isComponent(target) {\n  return isFunction(target) && target.hasOwnProperty('ɵcmp');\n}\n\nfunction hasOwnProperty(target, propertyName) {\n  return Object.prototype.hasOwnProperty.call(target, propertyName);\n}\n\nvar _ngrxMockEnvironment = false;\n\nfunction setNgrxMockEnvironment(value) {\n  _ngrxMockEnvironment = value;\n}\n\nfunction isNgrxMockEnvironment() {\n  return _ngrxMockEnvironment;\n}\n\nfunction isEqualCheck(a, b) {\n  return a === b;\n}\n\nfunction isArgumentsChanged(args, lastArguments, comparator) {\n  for (var i = 0; i < args.length; i++) {\n    if (!comparator(args[i], lastArguments[i])) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction resultMemoize(projectionFn, isResultEqual) {\n  return defaultMemoize(projectionFn, isEqualCheck, isResultEqual);\n}\n\nfunction defaultMemoize(projectionFn) {\n  var isArgumentsEqual = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : isEqualCheck;\n  var isResultEqual = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : isEqualCheck;\n  var lastArguments = null; // eslint-disable-next-line @typescript-eslint/no-explicit-any, , , , ,\n\n  var lastResult = null;\n  var overrideResult;\n\n  function reset() {\n    lastArguments = null;\n    lastResult = null;\n  }\n\n  function setResult() {\n    var result = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;\n    overrideResult = {\n      result: result\n    };\n  }\n\n  function clearResult() {\n    overrideResult = undefined;\n  }\n  /* eslint-disable prefer-rest-params, prefer-spread */\n  // disabled because of the use of `arguments`\n\n\n  function memoized() {\n    if (overrideResult !== undefined) {\n      return overrideResult.result;\n    }\n\n    if (!lastArguments) {\n      lastResult = projectionFn.apply(null, arguments);\n      lastArguments = arguments;\n      return lastResult;\n    }\n\n    if (!isArgumentsChanged(arguments, lastArguments, isArgumentsEqual)) {\n      return lastResult;\n    }\n\n    var newResult = projectionFn.apply(null, arguments);\n    lastArguments = arguments;\n\n    if (isResultEqual(lastResult, newResult)) {\n      return lastResult;\n    }\n\n    lastResult = newResult;\n    return newResult;\n  }\n\n  return {\n    memoized: memoized,\n    reset: reset,\n    setResult: setResult,\n    clearResult: clearResult\n  };\n}\n\nfunction createSelector() {\n  return createSelectorFactory(defaultMemoize).apply(void 0, arguments);\n}\n\nfunction defaultStateFn(state, selectors, props, memoizedProjector) {\n  if (props === undefined) {\n    var _args = selectors.map(function (fn) {\n      return fn(state);\n    });\n\n    return memoizedProjector.memoized.apply(null, _args);\n  }\n\n  var args = selectors.map(function (fn) {\n    return fn(state, props);\n  });\n  return memoizedProjector.memoized.apply(null, [].concat(_toConsumableArray(args), [props]));\n}\n/**\n *\n * @param memoize The function used to memoize selectors\n * @param options Config Object that may include a `stateFn` function defining how to return the selector's value, given the entire `Store`'s state, parent `Selector`s, `Props`, and a `MemoizedProjection`\n *\n * @usageNotes\n *\n * **Creating a Selector Factory Where Array Order Does Not Matter**\n *\n * ```ts\n * function removeMatch(arr: string[], target: string): string[] {\n *   const matchIndex = arr.indexOf(target);\n *   return [...arr.slice(0, matchIndex), ...arr.slice(matchIndex + 1)];\n * }\n *\n * function orderDoesNotMatterComparer(a: any, b: any): boolean {\n *   if (!Array.isArray(a) || !Array.isArray(b)) {\n *     return a === b;\n *   }\n *   if (a.length !== b.length) {\n *     return false;\n *   }\n *   let tempB = [...b];\n *   function reduceToDetermineIfArraysContainSameContents(\n *     previousCallResult: boolean,\n *     arrayMember: any\n *   ): boolean {\n *     if (previousCallResult === false) {\n *       return false;\n *     }\n *     if (tempB.includes(arrayMember)) {\n *       tempB = removeMatch(tempB, arrayMember);\n *       return true;\n *     }\n *     return false;\n *   }\n *   return a.reduce(reduceToDetermineIfArraysContainSameContents, true);\n * }\n *\n * export const creactOrderDoesNotMatterSelector = createSelectorFactory(\n *   (projectionFun) => defaultMemoize(\n *     projectionFun,\n *     orderDoesNotMatterComparer,\n *     orderDoesNotMatterComparer\n *   )\n * );\n * ```\n *\n * **Creating an Alternative Memoization Strategy**\n *\n * ```ts\n * function serialize(x: any): string {\n *   return JSON.stringify(x);\n * }\n *\n * export const createFullHistorySelector = createSelectorFactory(\n *  (projectionFunction) => {\n *    const cache = {};\n *\n *    function memoized() {\n *      const serializedArguments = serialize(...arguments);\n *       if (cache[serializedArguments] != null) {\n *         cache[serializedArguments] = projectionFunction.apply(null, arguments);\n *       }\n *       return cache[serializedArguments];\n *     }\n *     return {\n *       memoized,\n *       reset: () => {},\n *       setResult: () => {},\n *       clearResult: () => {},\n *     };\n *   }\n * );\n * ```\n *\n *\n */\n\n\nfunction createSelectorFactory(memoize) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n    stateFn: defaultStateFn\n  };\n  return function () {\n    for (var _len4 = arguments.length, input = new Array(_len4), _key5 = 0; _key5 < _len4; _key5++) {\n      input[_key5] = arguments[_key5];\n    }\n\n    var args = input;\n\n    if (Array.isArray(args[0])) {\n      var _args2 = args,\n          _args3 = _toArray(_args2),\n          head = _args3[0],\n          tail = _args3.slice(1);\n\n      args = [].concat(_toConsumableArray(head), _toConsumableArray(tail));\n    }\n\n    var selectors = args.slice(0, args.length - 1);\n    var projector = args[args.length - 1];\n    var memoizedSelectors = selectors.filter(function (selector) {\n      return selector.release && typeof selector.release === 'function';\n    });\n    var memoizedProjector = memoize(function () {\n      for (var _len5 = arguments.length, selectors = new Array(_len5), _key6 = 0; _key6 < _len5; _key6++) {\n        selectors[_key6] = arguments[_key6];\n      }\n\n      return projector.apply(null, selectors);\n    });\n    var memoizedState = defaultMemoize(function (state, props) {\n      return options.stateFn.apply(null, [state, selectors, props, memoizedProjector]);\n    });\n\n    function release() {\n      memoizedState.reset();\n      memoizedProjector.reset();\n      memoizedSelectors.forEach(function (selector) {\n        return selector.release();\n      });\n    }\n\n    return Object.assign(memoizedState.memoized, {\n      release: release,\n      projector: memoizedProjector.memoized,\n      setResult: memoizedState.setResult,\n      clearResult: memoizedState.clearResult\n    });\n  };\n}\n\nfunction createFeatureSelector(featureName) {\n  return createSelector(function (state) {\n    var featureState = state[featureName];\n\n    if (!isNgrxMockEnvironment() && isDevMode() && !(featureName in state)) {\n      console.warn(\"@ngrx/store: The feature name \\\"\".concat(featureName, \"\\\" does \") + 'not exist in the state, therefore createFeatureSelector ' + 'cannot access it.  Be sure it is imported in a loaded module ' + \"using StoreModule.forRoot('\".concat(featureName, \"', ...) or \") + \"StoreModule.forFeature('\".concat(featureName, \"', ...).  If the default \") + 'state is intended to be undefined, as is the case with router ' + 'state, this development-only warning message can be ignored.');\n    }\n\n    return featureState;\n  }, function (featureState) {\n    return featureState;\n  });\n}\n/**\n * @description\n * A function that accepts a feature name and a feature reducer, and creates\n * a feature selector and a selector for each feature state property.\n *\n * @param featureConfig An object that contains a feature name and a feature reducer.\n * @returns An object that contains a feature name, a feature reducer,\n * a feature selector, and a selector for each feature state property.\n *\n * @usageNotes\n *\n * **With Application State**\n *\n * ```ts\n * interface AppState {\n *   products: ProductsState;\n * }\n *\n * interface ProductsState {\n *   products: Product[];\n *   selectedId: string | null;\n * }\n *\n * const initialState: ProductsState = {\n *   products: [],\n *   selectedId: null,\n * };\n *\n * // AppState is passed as a generic argument\n * const productsFeature = createFeature<AppState>({\n *   name: 'products',\n *   reducer: createReducer(\n *     initialState,\n *     on(ProductsApiActions.loadSuccess(state, { products }) => ({\n *       ...state,\n *       products,\n *     }),\n *   ),\n * });\n *\n * const {\n *   selectProductsState, // type: MemoizedSelector<AppState, ProductsState>\n *   selectProducts, // type: MemoizedSelector<AppState, Product[]>\n *   selectSelectedId, // type: MemoizedSelector<AppState, string | null>\n * } = productsFeature;\n * ```\n *\n * **Without Application State**\n *\n * ```ts\n * const productsFeature = createFeature({\n *   name: 'products',\n *   reducer: createReducer(initialState),\n * });\n *\n * const {\n *   selectProductsState, // type: MemoizedSelector<Record<string, any>, ProductsState>\n *   selectProducts, // type: MemoizedSelector<Record<string, any>, Product[]>\n *   selectSelectedId, // type: MemoizedSelector<Record<string, any, string | null>\n * } = productsFeature;\n * ```\n */\n\n\nfunction createFeature(featureConfig) {\n  var name = featureConfig.name,\n      reducer = featureConfig.reducer;\n  var featureSelector = createFeatureSelector(name);\n  var nestedSelectors = createNestedSelectors(featureSelector, reducer);\n  return Object.assign(_defineProperty({\n    name: name,\n    reducer: reducer\n  }, \"select\".concat(capitalize(name), \"State\"), featureSelector), nestedSelectors);\n}\n\nfunction createNestedSelectors(featureSelector, reducer) {\n  var initialState = getInitialState(reducer);\n  var nestedKeys = isPlainObject(initialState) ? Object.keys(initialState) : [];\n  return nestedKeys.reduce(function (nestedSelectors, nestedKey) {\n    return Object.assign(Object.assign({}, nestedSelectors), _defineProperty({}, \"select\".concat(capitalize(nestedKey)), createSelector(featureSelector, function (parentState) {\n      return parentState === null || parentState === void 0 ? void 0 : parentState[nestedKey];\n    })));\n  }, {});\n}\n\nfunction getInitialState(reducer) {\n  return reducer(undefined, {\n    type: '@ngrx/feature/init'\n  });\n}\n\nfunction immutabilityCheckMetaReducer(reducer, checks) {\n  return function (state, action) {\n    var act = checks.action(action) ? freeze(action) : action;\n    var nextState = reducer(state, act);\n    return checks.state() ? freeze(nextState) : nextState;\n  };\n}\n\nfunction freeze(target) {\n  Object.freeze(target);\n  var targetIsFunction = isFunction(target);\n  Object.getOwnPropertyNames(target).forEach(function (prop) {\n    // Ignore Ivy properties, ref: https://github.com/ngrx/platform/issues/2109#issuecomment-582689060\n    if (prop.startsWith('ɵ')) {\n      return;\n    }\n\n    if (hasOwnProperty(target, prop) && (targetIsFunction ? prop !== 'caller' && prop !== 'callee' && prop !== 'arguments' : true)) {\n      var propValue = target[prop];\n\n      if ((isObjectLike(propValue) || isFunction(propValue)) && !Object.isFrozen(propValue)) {\n        freeze(propValue);\n      }\n    }\n  });\n  return target;\n}\n\nfunction serializationCheckMetaReducer(reducer, checks) {\n  return function (state, action) {\n    if (checks.action(action)) {\n      var unserializableAction = getUnserializable(action);\n      throwIfUnserializable(unserializableAction, 'action');\n    }\n\n    var nextState = reducer(state, action);\n\n    if (checks.state()) {\n      var unserializableState = getUnserializable(nextState);\n      throwIfUnserializable(unserializableState, 'state');\n    }\n\n    return nextState;\n  };\n}\n\nfunction getUnserializable(target) {\n  var path = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\n  // Guard against undefined and null, e.g. a reducer that returns undefined\n  if ((isUndefined(target) || isNull(target)) && path.length === 0) {\n    return {\n      path: ['root'],\n      value: target\n    };\n  }\n\n  var keys = Object.keys(target);\n  return keys.reduce(function (result, key) {\n    if (result) {\n      return result;\n    }\n\n    var value = target[key]; // Ignore Ivy components\n\n    if (isComponent(value)) {\n      return result;\n    }\n\n    if (isUndefined(value) || isNull(value) || isNumber(value) || isBoolean(value) || isString(value) || isArray(value)) {\n      return false;\n    }\n\n    if (isPlainObject(value)) {\n      return getUnserializable(value, [].concat(_toConsumableArray(path), [key]));\n    }\n\n    return {\n      path: [].concat(_toConsumableArray(path), [key]),\n      value: value\n    };\n  }, false);\n}\n\nfunction throwIfUnserializable(unserializable, context) {\n  if (unserializable === false) {\n    return;\n  }\n\n  var unserializablePath = unserializable.path.join('.');\n  var error = new Error(\"Detected unserializable \".concat(context, \" at \\\"\").concat(unserializablePath, \"\\\". \").concat(RUNTIME_CHECK_URL, \"#strict\").concat(context, \"serializability\"));\n  error.value = unserializable.value;\n  error.unserializablePath = unserializablePath;\n  throw error;\n}\n\nfunction inNgZoneAssertMetaReducer(reducer, checks) {\n  return function (state, action) {\n    if (checks.action(action) && !i0.NgZone.isInAngularZone()) {\n      throw new Error(\"Action '\".concat(action.type, \"' running outside NgZone. \").concat(RUNTIME_CHECK_URL, \"#strictactionwithinngzone\"));\n    }\n\n    return reducer(state, action);\n  };\n}\n\nfunction createActiveRuntimeChecks(runtimeChecks) {\n  if (isDevMode()) {\n    return Object.assign({\n      strictStateSerializability: false,\n      strictActionSerializability: false,\n      strictStateImmutability: true,\n      strictActionImmutability: true,\n      strictActionWithinNgZone: false,\n      strictActionTypeUniqueness: false\n    }, runtimeChecks);\n  }\n\n  return {\n    strictStateSerializability: false,\n    strictActionSerializability: false,\n    strictStateImmutability: false,\n    strictActionImmutability: false,\n    strictActionWithinNgZone: false,\n    strictActionTypeUniqueness: false\n  };\n}\n\nfunction createSerializationCheckMetaReducer(_ref5) {\n  var strictActionSerializability = _ref5.strictActionSerializability,\n      strictStateSerializability = _ref5.strictStateSerializability;\n  return function (reducer) {\n    return strictActionSerializability || strictStateSerializability ? serializationCheckMetaReducer(reducer, {\n      action: function action(_action) {\n        return strictActionSerializability && !ignoreNgrxAction(_action);\n      },\n      state: function state() {\n        return strictStateSerializability;\n      }\n    }) : reducer;\n  };\n}\n\nfunction createImmutabilityCheckMetaReducer(_ref6) {\n  var strictActionImmutability = _ref6.strictActionImmutability,\n      strictStateImmutability = _ref6.strictStateImmutability;\n  return function (reducer) {\n    return strictActionImmutability || strictStateImmutability ? immutabilityCheckMetaReducer(reducer, {\n      action: function action(_action2) {\n        return strictActionImmutability && !ignoreNgrxAction(_action2);\n      },\n      state: function state() {\n        return strictStateImmutability;\n      }\n    }) : reducer;\n  };\n}\n\nfunction ignoreNgrxAction(action) {\n  return action.type.startsWith('@ngrx');\n}\n\nfunction createInNgZoneCheckMetaReducer(_ref7) {\n  var strictActionWithinNgZone = _ref7.strictActionWithinNgZone;\n  return function (reducer) {\n    return strictActionWithinNgZone ? inNgZoneAssertMetaReducer(reducer, {\n      action: function action(_action3) {\n        return strictActionWithinNgZone && !ignoreNgrxAction(_action3);\n      }\n    }) : reducer;\n  };\n}\n\nfunction provideRuntimeChecks(runtimeChecks) {\n  return [{\n    provide: _USER_RUNTIME_CHECKS,\n    useValue: runtimeChecks\n  }, {\n    provide: USER_RUNTIME_CHECKS,\n    useFactory: _runtimeChecksFactory,\n    deps: [_USER_RUNTIME_CHECKS]\n  }, {\n    provide: ACTIVE_RUNTIME_CHECKS,\n    deps: [USER_RUNTIME_CHECKS],\n    useFactory: createActiveRuntimeChecks\n  }, {\n    provide: META_REDUCERS,\n    multi: true,\n    deps: [ACTIVE_RUNTIME_CHECKS],\n    useFactory: createImmutabilityCheckMetaReducer\n  }, {\n    provide: META_REDUCERS,\n    multi: true,\n    deps: [ACTIVE_RUNTIME_CHECKS],\n    useFactory: createSerializationCheckMetaReducer\n  }, {\n    provide: META_REDUCERS,\n    multi: true,\n    deps: [ACTIVE_RUNTIME_CHECKS],\n    useFactory: createInNgZoneCheckMetaReducer\n  }];\n}\n\nfunction checkForActionTypeUniqueness() {\n  return [{\n    provide: _ACTION_TYPE_UNIQUENESS_CHECK,\n    multi: true,\n    deps: [ACTIVE_RUNTIME_CHECKS],\n    useFactory: _actionTypeUniquenessCheck\n  }];\n}\n\nfunction _runtimeChecksFactory(runtimeChecks) {\n  return runtimeChecks;\n}\n\nfunction _actionTypeUniquenessCheck(config) {\n  if (!config.strictActionTypeUniqueness) {\n    return;\n  }\n\n  var duplicates = Object.entries(REGISTERED_ACTION_TYPES).filter(function (_ref8) {\n    var _ref9 = _slicedToArray(_ref8, 2),\n        registrations = _ref9[1];\n\n    return registrations > 1;\n  }).map(function (_ref10) {\n    var _ref11 = _slicedToArray(_ref10, 1),\n        type = _ref11[0];\n\n    return type;\n  });\n\n  if (duplicates.length) {\n    throw new Error(\"Action types are registered more than once, \".concat(duplicates.map(function (type) {\n      return \"\\\"\".concat(type, \"\\\"\");\n    }).join(', '), \". \").concat(RUNTIME_CHECK_URL, \"#strictactiontypeuniqueness\"));\n  }\n}\n\nvar StoreRootModule = /*#__PURE__*/(function () {\n  var StoreRootModule = /*#__PURE__*/_createClass(function StoreRootModule(actions$, reducer$, scannedActions$, store, guard, actionCheck) {\n    _classCallCheck(this, StoreRootModule);\n  });\n\n  /** @nocollapse */\n\n  /** @nocollapse */\n  StoreRootModule.ɵfac = function StoreRootModule_Factory(t) {\n    return new (t || StoreRootModule)(i0.ɵɵinject(ActionsSubject), i0.ɵɵinject(ReducerObservable), i0.ɵɵinject(ScannedActionsSubject), i0.ɵɵinject(Store), i0.ɵɵinject(_ROOT_STORE_GUARD, 8), i0.ɵɵinject(_ACTION_TYPE_UNIQUENESS_CHECK, 8));\n  };\n  /** @nocollapse */\n\n  /** @nocollapse */\n\n\n  StoreRootModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: StoreRootModule\n  });\n  /** @nocollapse */\n\n  /** @nocollapse */\n\n  StoreRootModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n  return StoreRootModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nvar StoreFeatureModule = /*#__PURE__*/(function () {\n  var StoreFeatureModule = /*#__PURE__*/function () {\n    function StoreFeatureModule(features, featureReducers, reducerManager, root, actionCheck) {\n      _classCallCheck(this, StoreFeatureModule);\n\n      this.features = features;\n      this.featureReducers = featureReducers;\n      this.reducerManager = reducerManager;\n      var feats = features.map(function (feature, index) {\n        var featureReducerCollection = featureReducers.shift(); // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n\n        var reducers = featureReducerCollection\n        /*TODO(#823)*/\n        [index];\n        return Object.assign(Object.assign({}, feature), {\n          reducers: reducers,\n          initialState: _initialStateFactory(feature.initialState)\n        });\n      });\n      reducerManager.addFeatures(feats);\n    } // eslint-disable-next-line @angular-eslint/contextual-lifecycle\n\n\n    _createClass(StoreFeatureModule, [{\n      key: \"ngOnDestroy\",\n      value: function ngOnDestroy() {\n        this.reducerManager.removeFeatures(this.features);\n      }\n    }]);\n\n    return StoreFeatureModule;\n  }();\n\n  /** @nocollapse */\n\n  /** @nocollapse */\n  StoreFeatureModule.ɵfac = function StoreFeatureModule_Factory(t) {\n    return new (t || StoreFeatureModule)(i0.ɵɵinject(_STORE_FEATURES), i0.ɵɵinject(FEATURE_REDUCERS), i0.ɵɵinject(ReducerManager), i0.ɵɵinject(StoreRootModule), i0.ɵɵinject(_ACTION_TYPE_UNIQUENESS_CHECK, 8));\n  };\n  /** @nocollapse */\n\n  /** @nocollapse */\n\n\n  StoreFeatureModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: StoreFeatureModule\n  });\n  /** @nocollapse */\n\n  /** @nocollapse */\n\n  StoreFeatureModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n  return StoreFeatureModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nvar StoreModule = /*#__PURE__*/(function () {\n  var StoreModule = /*#__PURE__*/function () {\n    function StoreModule() {\n      _classCallCheck(this, StoreModule);\n    }\n\n    _createClass(StoreModule, null, [{\n      key: \"forRoot\",\n      value: function forRoot(reducers) {\n        var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        return {\n          ngModule: StoreRootModule,\n          providers: [{\n            provide: _ROOT_STORE_GUARD,\n            useFactory: _provideForRootGuard,\n            deps: [[Store, new Optional(), new SkipSelf()]]\n          }, {\n            provide: _INITIAL_STATE,\n            useValue: config.initialState\n          }, {\n            provide: INITIAL_STATE,\n            useFactory: _initialStateFactory,\n            deps: [_INITIAL_STATE]\n          }, {\n            provide: _INITIAL_REDUCERS,\n            useValue: reducers\n          }, {\n            provide: _STORE_REDUCERS,\n            useExisting: reducers instanceof InjectionToken ? reducers : _INITIAL_REDUCERS\n          }, {\n            provide: INITIAL_REDUCERS,\n            deps: [Injector, _INITIAL_REDUCERS, [new Inject(_STORE_REDUCERS)]],\n            useFactory: _createStoreReducers\n          }, {\n            provide: USER_PROVIDED_META_REDUCERS,\n            useValue: config.metaReducers ? config.metaReducers : []\n          }, {\n            provide: _RESOLVED_META_REDUCERS,\n            deps: [META_REDUCERS, USER_PROVIDED_META_REDUCERS],\n            useFactory: _concatMetaReducers\n          }, {\n            provide: _REDUCER_FACTORY,\n            useValue: config.reducerFactory ? config.reducerFactory : combineReducers\n          }, {\n            provide: REDUCER_FACTORY,\n            deps: [_REDUCER_FACTORY, _RESOLVED_META_REDUCERS],\n            useFactory: createReducerFactory\n          }, ACTIONS_SUBJECT_PROVIDERS, REDUCER_MANAGER_PROVIDERS, SCANNED_ACTIONS_SUBJECT_PROVIDERS, STATE_PROVIDERS, STORE_PROVIDERS, provideRuntimeChecks(config.runtimeChecks), checkForActionTypeUniqueness()]\n        };\n      }\n    }, {\n      key: \"forFeature\",\n      value: function forFeature(featureNameOrSlice, reducers) {\n        var config = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        return {\n          ngModule: StoreFeatureModule,\n          providers: [{\n            provide: _FEATURE_CONFIGS,\n            multi: true,\n            useValue: featureNameOrSlice instanceof Object ? {} : config\n          }, {\n            provide: STORE_FEATURES,\n            multi: true,\n            useValue: {\n              key: featureNameOrSlice instanceof Object ? featureNameOrSlice.name : featureNameOrSlice,\n              reducerFactory: !(config instanceof InjectionToken) && config.reducerFactory ? config.reducerFactory : combineReducers,\n              metaReducers: !(config instanceof InjectionToken) && config.metaReducers ? config.metaReducers : [],\n              initialState: !(config instanceof InjectionToken) && config.initialState ? config.initialState : undefined\n            }\n          }, {\n            provide: _STORE_FEATURES,\n            deps: [Injector, _FEATURE_CONFIGS, STORE_FEATURES],\n            useFactory: _createFeatureStore\n          }, {\n            provide: _FEATURE_REDUCERS,\n            multi: true,\n            useValue: featureNameOrSlice instanceof Object ? featureNameOrSlice.reducer : reducers\n          }, {\n            provide: _FEATURE_REDUCERS_TOKEN,\n            multi: true,\n            useExisting: reducers instanceof InjectionToken ? reducers : _FEATURE_REDUCERS\n          }, {\n            provide: FEATURE_REDUCERS,\n            multi: true,\n            deps: [Injector, _FEATURE_REDUCERS, [new Inject(_FEATURE_REDUCERS_TOKEN)]],\n            useFactory: _createFeatureReducers\n          }, checkForActionTypeUniqueness()]\n        };\n      }\n    }]);\n\n    return StoreModule;\n  }();\n\n  /** @nocollapse */\n\n  /** @nocollapse */\n  StoreModule.ɵfac = function StoreModule_Factory(t) {\n    return new (t || StoreModule)();\n  };\n  /** @nocollapse */\n\n  /** @nocollapse */\n\n\n  StoreModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: StoreModule\n  });\n  /** @nocollapse */\n\n  /** @nocollapse */\n\n  StoreModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n  return StoreModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nfunction _createStoreReducers(injector, reducers) {\n  return reducers instanceof InjectionToken ? injector.get(reducers) : reducers;\n}\n\nfunction _createFeatureStore(injector, configs, featureStores) {\n  return featureStores.map(function (feat, index) {\n    if (configs[index] instanceof InjectionToken) {\n      var conf = injector.get(configs[index]);\n      return {\n        key: feat.key,\n        reducerFactory: conf.reducerFactory ? conf.reducerFactory : combineReducers,\n        metaReducers: conf.metaReducers ? conf.metaReducers : [],\n        initialState: conf.initialState\n      };\n    }\n\n    return feat;\n  });\n}\n\nfunction _createFeatureReducers(injector, reducerCollection) {\n  var reducers = reducerCollection.map(function (reducer) {\n    return reducer instanceof InjectionToken ? injector.get(reducer) : reducer;\n  });\n  return reducers;\n}\n\nfunction _initialStateFactory(initialState) {\n  if (typeof initialState === 'function') {\n    return initialState();\n  }\n\n  return initialState;\n}\n\nfunction _concatMetaReducers(metaReducers, userProvidedMetaReducers) {\n  return metaReducers.concat(userProvidedMetaReducers);\n}\n\nfunction _provideForRootGuard(store) {\n  if (store) {\n    throw new TypeError(\"StoreModule.forRoot() called twice. Feature modules should use StoreModule.forFeature() instead.\");\n  }\n\n  return 'guarded';\n}\n/**\n * @description\n * Associates actions with a given state change function.\n * A state change function must be provided as the last parameter.\n *\n * @param args `ActionCreator`'s followed by a state change function.\n *\n * @returns an association of action types with a state change function.\n *\n * @usageNotes\n * ```ts\n * on(AuthApiActions.loginSuccess, (state, { user }) => ({ ...state, user }))\n * ```\n */\n\n\nfunction on() {\n  for (var _len6 = arguments.length, args = new Array(_len6), _key7 = 0; _key7 < _len6; _key7++) {\n    args[_key7] = arguments[_key7];\n  }\n\n  // This could be refactored when TS releases the version with this fix:\n  // https://github.com/microsoft/TypeScript/pull/41544\n  var reducer = args.pop();\n  var types = args.map(function (creator) {\n    return creator.type;\n  });\n  return {\n    reducer: reducer,\n    types: types\n  };\n}\n/**\n * @description\n * Creates a reducer function to handle state transitions.\n *\n * Reducer creators reduce the explicitness of reducer functions with switch statements.\n *\n * @param initialState Provides a state value if the current state is `undefined`, as it is initially.\n * @param ons Associations between actions and state changes.\n * @returns A reducer function.\n *\n * @usageNotes\n *\n * - Must be used with `ActionCreator`'s (returned by `createAction`). Cannot be used with class-based action creators.\n * - The returned `ActionReducer` should additionally be wrapped with another function, if you are using View Engine AOT.\n * In case you are using Ivy (or only JIT View Engine) the extra wrapper function is not required.\n *\n * **Declaring a reducer creator**\n *\n * ```ts\n * export const reducer = createReducer(\n *   initialState,\n *   on(\n *     featureActions.actionOne,\n *     featureActions.actionTwo,\n *     (state, { updatedValue }) => ({ ...state, prop: updatedValue })\n *   ),\n *   on(featureActions.actionThree, () => initialState);\n * );\n * ```\n *\n * **Declaring a reducer creator using a wrapper function (Only needed if using View Engine AOT)**\n *\n * ```ts\n * const featureReducer = createReducer(\n *   initialState,\n *   on(\n *     featureActions.actionOne,\n *     featureActions.actionTwo,\n *     (state, { updatedValue }) => ({ ...state, prop: updatedValue })\n *   ),\n *   on(featureActions.actionThree, () => initialState);\n * );\n *\n * export function reducer(state: State | undefined, action: Action) {\n *   return featureReducer(state, action);\n * }\n * ```\n */\n\n\nfunction createReducer(initialState) {\n  var map = new Map();\n\n  for (var _len7 = arguments.length, ons = new Array(_len7 > 1 ? _len7 - 1 : 0), _key8 = 1; _key8 < _len7; _key8++) {\n    ons[_key8 - 1] = arguments[_key8];\n  }\n\n  var _loop = function _loop() {\n    var on = _ons[_i3];\n\n    var _iterator = _createForOfIteratorHelper(on.types),\n        _step;\n\n    try {\n      var _loop2 = function _loop2() {\n        var type = _step.value;\n        var existingReducer = map.get(type);\n\n        if (existingReducer) {\n          var newReducer = function newReducer(state, action) {\n            return on.reducer(existingReducer(state, action), action);\n          };\n\n          map.set(type, newReducer);\n        } else {\n          map.set(type, on.reducer);\n        }\n      };\n\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        _loop2();\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n  };\n\n  for (var _i3 = 0, _ons = ons; _i3 < _ons.length; _i3++) {\n    _loop();\n  }\n\n  return function () {\n    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : initialState;\n    var action = arguments.length > 1 ? arguments[1] : undefined;\n    var reducer = map.get(action.type);\n    return reducer ? reducer(state, action) : state;\n  };\n}\n/**\n * DO NOT EDIT\n *\n * This file is automatically generated at build\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { ACTIVE_RUNTIME_CHECKS, ActionsSubject, FEATURE_REDUCERS, INIT, INITIAL_REDUCERS, INITIAL_STATE, META_REDUCERS, REDUCER_FACTORY, ReducerManager, ReducerManagerDispatcher, ReducerObservable, STORE_FEATURES, ScannedActionsSubject, State, StateObservable, Store, StoreFeatureModule, StoreModule, StoreRootModule, UPDATE, USER_PROVIDED_META_REDUCERS, USER_RUNTIME_CHECKS, combineReducers, compose, createAction, createFeature, createFeatureSelector, createReducer, createReducerFactory, createSelector, createSelectorFactory, defaultMemoize, defaultStateFn, isNgrxMockEnvironment, on, props, reduceState, resultMemoize, _select as select, setNgrxMockEnvironment, union };","map":null,"metadata":{},"sourceType":"module"}