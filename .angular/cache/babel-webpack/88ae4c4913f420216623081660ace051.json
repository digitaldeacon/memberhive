{"ast":null,"code":"import _inherits from \"/Applications/MAMP/htdocs/memberhive/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Applications/MAMP/htdocs/memberhive/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport _createClass from \"/Applications/MAMP/htdocs/memberhive/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _classCallCheck from \"/Applications/MAMP/htdocs/memberhive/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport { coerceBooleanProperty } from '@angular/cdk/coercion';\nimport * as i1 from '@angular/cdk/platform';\nimport { getSupportedInputTypes } from '@angular/cdk/platform';\nimport * as i0 from '@angular/core';\nimport { InjectionToken, Directive, Optional, Self, Inject, Input, NgModule } from '@angular/core';\nimport * as i2 from '@angular/forms';\nimport { Validators } from '@angular/forms';\nimport * as i3 from '@angular/material/core';\nimport { mixinErrorState, MatCommonModule, ErrorStateMatcher } from '@angular/material/core';\nimport * as i5 from '@angular/material/form-field';\nimport { MAT_FORM_FIELD, MatFormFieldControl, MatFormFieldModule } from '@angular/material/form-field';\nimport { Subject } from 'rxjs';\nimport * as i4 from '@angular/cdk/text-field';\nimport { TextFieldModule } from '@angular/cdk/text-field';\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/** @docs-private */\n\nfunction getMatInputUnsupportedTypeError(type) {\n  return Error(\"Input type \\\"\".concat(type, \"\\\" isn't supported by matInput.\"));\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * This token is used to inject the object whose value should be set into `MatInput`. If none is\n * provided, the native `HTMLInputElement` is used. Directives like `MatDatepickerInput` can provide\n * themselves for this token, in order to make `MatInput` delegate the getting and setting of the\n * value to them.\n */\n\n\nvar MAT_INPUT_VALUE_ACCESSOR = /*#__PURE__*/new InjectionToken('MAT_INPUT_VALUE_ACCESSOR');\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n// Invalid input type. Using one of these will throw an MatInputUnsupportedTypeError.\n\nvar MAT_INPUT_INVALID_TYPES = ['button', 'checkbox', 'file', 'hidden', 'image', 'radio', 'range', 'reset', 'submit'];\nvar nextUniqueId = 0; // Boilerplate for applying mixins to MatInput.\n\n/** @docs-private */\n\nvar _MatInputBase = /*#__PURE__*/mixinErrorState( /*#__PURE__*/function () {\n  function _class(_defaultErrorStateMatcher, _parentForm, _parentFormGroup,\n  /** @docs-private */\n  ngControl) {\n    _classCallCheck(this, _class);\n\n    this._defaultErrorStateMatcher = _defaultErrorStateMatcher;\n    this._parentForm = _parentForm;\n    this._parentFormGroup = _parentFormGroup;\n    this.ngControl = ngControl;\n  }\n\n  return _createClass(_class);\n}());\n/** Directive that allows a native input to work inside a `MatFormField`. */\n\n\nvar MatInput = /*#__PURE__*/(function () {\n  var MatInput = /*#__PURE__*/function (_MatInputBase2) {\n    _inherits(MatInput, _MatInputBase2);\n\n    var _super = _createSuper(MatInput);\n\n    function MatInput(_elementRef, _platform, ngControl, _parentForm, _parentFormGroup, _defaultErrorStateMatcher, inputValueAccessor, _autofillMonitor, ngZone, // TODO: Remove this once the legacy appearance has been removed. We only need\n    // to inject the form-field for determining whether the placeholder has been promoted.\n    _formField) {\n      var _this;\n\n      _classCallCheck(this, MatInput);\n\n      _this = _super.call(this, _defaultErrorStateMatcher, _parentForm, _parentFormGroup, ngControl);\n      _this._elementRef = _elementRef;\n      _this._platform = _platform;\n      _this._autofillMonitor = _autofillMonitor;\n      _this._formField = _formField;\n      _this._uid = \"mat-input-\".concat(nextUniqueId++);\n      /**\n       * Implemented as part of MatFormFieldControl.\n       * @docs-private\n       */\n\n      _this.focused = false;\n      /**\n       * Implemented as part of MatFormFieldControl.\n       * @docs-private\n       */\n\n      _this.stateChanges = new Subject();\n      /**\n       * Implemented as part of MatFormFieldControl.\n       * @docs-private\n       */\n\n      _this.controlType = 'mat-input';\n      /**\n       * Implemented as part of MatFormFieldControl.\n       * @docs-private\n       */\n\n      _this.autofilled = false;\n      _this._disabled = false;\n      _this._type = 'text';\n      _this._readonly = false;\n      _this._neverEmptyInputTypes = ['date', 'datetime', 'datetime-local', 'month', 'time', 'week'].filter(function (t) {\n        return getSupportedInputTypes().has(t);\n      });\n      var element = _this._elementRef.nativeElement;\n      var nodeName = element.nodeName.toLowerCase(); // If no input value accessor was explicitly specified, use the element as the input value\n      // accessor.\n\n      _this._inputValueAccessor = inputValueAccessor || element;\n      _this._previousNativeValue = _this.value; // Force setter to be called in case id was not specified.\n\n      _this.id = _this.id; // On some versions of iOS the caret gets stuck in the wrong place when holding down the delete\n      // key. In order to get around this we need to \"jiggle\" the caret loose. Since this bug only\n      // exists on iOS, we only bother to install the listener on iOS.\n\n      if (_platform.IOS) {\n        ngZone.runOutsideAngular(function () {\n          _elementRef.nativeElement.addEventListener('keyup', function (event) {\n            var el = event.target; // Note: We specifically check for 0, rather than `!el.selectionStart`, because the two\n            // indicate different things. If the value is 0, it means that the caret is at the start\n            // of the input, whereas a value of `null` means that the input doesn't support\n            // manipulating the selection range. Inputs that don't support setting the selection range\n            // will throw an error so we want to avoid calling `setSelectionRange` on them. See:\n            // https://html.spec.whatwg.org/multipage/input.html#do-not-apply\n\n            if (!el.value && el.selectionStart === 0 && el.selectionEnd === 0) {\n              // Note: Just setting `0, 0` doesn't fix the issue. Setting\n              // `1, 1` fixes it for the first time that you type text and\n              // then hold delete. Toggling to `1, 1` and then back to\n              // `0, 0` seems to completely fix it.\n              el.setSelectionRange(1, 1);\n              el.setSelectionRange(0, 0);\n            }\n          });\n        });\n      }\n\n      _this._isServer = !_this._platform.isBrowser;\n      _this._isNativeSelect = nodeName === 'select';\n      _this._isTextarea = nodeName === 'textarea';\n      _this._isInFormField = !!_formField;\n\n      if (_this._isNativeSelect) {\n        _this.controlType = element.multiple ? 'mat-native-select-multiple' : 'mat-native-select';\n      }\n\n      return _this;\n    }\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * @docs-private\n     */\n\n\n    _createClass(MatInput, [{\n      key: \"disabled\",\n      get: function get() {\n        if (this.ngControl && this.ngControl.disabled !== null) {\n          return this.ngControl.disabled;\n        }\n\n        return this._disabled;\n      },\n      set: function set(value) {\n        this._disabled = coerceBooleanProperty(value); // Browsers may not fire the blur event if the input is disabled too quickly.\n        // Reset from here to ensure that the element doesn't become stuck.\n\n        if (this.focused) {\n          this.focused = false;\n          this.stateChanges.next();\n        }\n      }\n      /**\n       * Implemented as part of MatFormFieldControl.\n       * @docs-private\n       */\n\n    }, {\n      key: \"id\",\n      get: function get() {\n        return this._id;\n      },\n      set: function set(value) {\n        this._id = value || this._uid;\n      }\n      /**\n       * Implemented as part of MatFormFieldControl.\n       * @docs-private\n       */\n\n    }, {\n      key: \"required\",\n      get: function get() {\n        var _a, _b, _c, _d;\n\n        return (_d = (_a = this._required) !== null && _a !== void 0 ? _a : (_c = (_b = this.ngControl) === null || _b === void 0 ? void 0 : _b.control) === null || _c === void 0 ? void 0 : _c.hasValidator(Validators.required)) !== null && _d !== void 0 ? _d : false;\n      },\n      set: function set(value) {\n        this._required = coerceBooleanProperty(value);\n      }\n      /** Input type of the element. */\n\n    }, {\n      key: \"type\",\n      get: function get() {\n        return this._type;\n      },\n      set: function set(value) {\n        this._type = value || 'text';\n\n        this._validateType(); // When using Angular inputs, developers are no longer able to set the properties on the native\n        // input element. To ensure that bindings for `type` work, we need to sync the setter\n        // with the native property. Textarea elements don't support the type property or attribute.\n\n\n        if (!this._isTextarea && getSupportedInputTypes().has(this._type)) {\n          this._elementRef.nativeElement.type = this._type;\n        }\n      }\n      /**\n       * Implemented as part of MatFormFieldControl.\n       * @docs-private\n       */\n\n    }, {\n      key: \"value\",\n      get: function get() {\n        return this._inputValueAccessor.value;\n      },\n      set: function set(value) {\n        if (value !== this.value) {\n          this._inputValueAccessor.value = value;\n          this.stateChanges.next();\n        }\n      }\n      /** Whether the element is readonly. */\n\n    }, {\n      key: \"readonly\",\n      get: function get() {\n        return this._readonly;\n      },\n      set: function set(value) {\n        this._readonly = coerceBooleanProperty(value);\n      }\n    }, {\n      key: \"ngAfterViewInit\",\n      value: function ngAfterViewInit() {\n        var _this2 = this;\n\n        if (this._platform.isBrowser) {\n          this._autofillMonitor.monitor(this._elementRef.nativeElement).subscribe(function (event) {\n            _this2.autofilled = event.isAutofilled;\n\n            _this2.stateChanges.next();\n          });\n        }\n      }\n    }, {\n      key: \"ngOnChanges\",\n      value: function ngOnChanges() {\n        this.stateChanges.next();\n      }\n    }, {\n      key: \"ngOnDestroy\",\n      value: function ngOnDestroy() {\n        this.stateChanges.complete();\n\n        if (this._platform.isBrowser) {\n          this._autofillMonitor.stopMonitoring(this._elementRef.nativeElement);\n        }\n      }\n    }, {\n      key: \"ngDoCheck\",\n      value: function ngDoCheck() {\n        if (this.ngControl) {\n          // We need to re-evaluate this on every change detection cycle, because there are some\n          // error triggers that we can't subscribe to (e.g. parent form submissions). This means\n          // that whatever logic is in here has to be super lean or we risk destroying the performance.\n          this.updateErrorState();\n        } // We need to dirty-check the native element's value, because there are some cases where\n        // we won't be notified when it changes (e.g. the consumer isn't using forms or they're\n        // updating the value using `emitEvent: false`).\n\n\n        this._dirtyCheckNativeValue(); // We need to dirty-check and set the placeholder attribute ourselves, because whether it's\n        // present or not depends on a query which is prone to \"changed after checked\" errors.\n\n\n        this._dirtyCheckPlaceholder();\n      }\n      /** Focuses the input. */\n\n    }, {\n      key: \"focus\",\n      value: function focus(options) {\n        this._elementRef.nativeElement.focus(options);\n      }\n      /** Callback for the cases where the focused state of the input changes. */\n\n    }, {\n      key: \"_focusChanged\",\n      value: function _focusChanged(isFocused) {\n        if (isFocused !== this.focused) {\n          this.focused = isFocused;\n          this.stateChanges.next();\n        }\n      }\n    }, {\n      key: \"_onInput\",\n      value: function _onInput() {// This is a noop function and is used to let Angular know whenever the value changes.\n        // Angular will run a new change detection each time the `input` event has been dispatched.\n        // It's necessary that Angular recognizes the value change, because when floatingLabel\n        // is set to false and Angular forms aren't used, the placeholder won't recognize the\n        // value changes and will not disappear.\n        // Listening to the input event wouldn't be necessary when the input is using the\n        // FormsModule or ReactiveFormsModule, because Angular forms also listens to input events.\n      }\n      /** Does some manual dirty checking on the native input `placeholder` attribute. */\n\n    }, {\n      key: \"_dirtyCheckPlaceholder\",\n      value: function _dirtyCheckPlaceholder() {\n        var _a, _b; // If we're hiding the native placeholder, it should also be cleared from the DOM, otherwise\n        // screen readers will read it out twice: once from the label and once from the attribute.\n        // TODO: can be removed once we get rid of the `legacy` style for the form field, because it's\n        // the only one that supports promoting the placeholder to a label.\n\n\n        var placeholder = ((_b = (_a = this._formField) === null || _a === void 0 ? void 0 : _a._hideControlPlaceholder) === null || _b === void 0 ? void 0 : _b.call(_a)) ? null : this.placeholder;\n\n        if (placeholder !== this._previousPlaceholder) {\n          var element = this._elementRef.nativeElement;\n          this._previousPlaceholder = placeholder;\n          placeholder ? element.setAttribute('placeholder', placeholder) : element.removeAttribute('placeholder');\n        }\n      }\n      /** Does some manual dirty checking on the native input `value` property. */\n\n    }, {\n      key: \"_dirtyCheckNativeValue\",\n      value: function _dirtyCheckNativeValue() {\n        var newValue = this._elementRef.nativeElement.value;\n\n        if (this._previousNativeValue !== newValue) {\n          this._previousNativeValue = newValue;\n          this.stateChanges.next();\n        }\n      }\n      /** Make sure the input is a supported type. */\n\n    }, {\n      key: \"_validateType\",\n      value: function _validateType() {\n        if (MAT_INPUT_INVALID_TYPES.indexOf(this._type) > -1 && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n          throw getMatInputUnsupportedTypeError(this._type);\n        }\n      }\n      /** Checks whether the input type is one of the types that are never empty. */\n\n    }, {\n      key: \"_isNeverEmpty\",\n      value: function _isNeverEmpty() {\n        return this._neverEmptyInputTypes.indexOf(this._type) > -1;\n      }\n      /** Checks whether the input is invalid based on the native validation. */\n\n    }, {\n      key: \"_isBadInput\",\n      value: function _isBadInput() {\n        // The `validity` property won't be present on platform-server.\n        var validity = this._elementRef.nativeElement.validity;\n        return validity && validity.badInput;\n      }\n      /**\n       * Implemented as part of MatFormFieldControl.\n       * @docs-private\n       */\n\n    }, {\n      key: \"empty\",\n      get: function get() {\n        return !this._isNeverEmpty() && !this._elementRef.nativeElement.value && !this._isBadInput() && !this.autofilled;\n      }\n      /**\n       * Implemented as part of MatFormFieldControl.\n       * @docs-private\n       */\n\n    }, {\n      key: \"shouldLabelFloat\",\n      get: function get() {\n        if (this._isNativeSelect) {\n          // For a single-selection `<select>`, the label should float when the selected option has\n          // a non-empty display value. For a `<select multiple>`, the label *always* floats to avoid\n          // overlapping the label with the options.\n          var selectElement = this._elementRef.nativeElement;\n          var firstOption = selectElement.options[0]; // On most browsers the `selectedIndex` will always be 0, however on IE and Edge it'll be\n          // -1 if the `value` is set to something, that isn't in the list of options, at a later point.\n\n          return this.focused || selectElement.multiple || !this.empty || !!(selectElement.selectedIndex > -1 && firstOption && firstOption.label);\n        } else {\n          return this.focused || !this.empty;\n        }\n      }\n      /**\n       * Implemented as part of MatFormFieldControl.\n       * @docs-private\n       */\n\n    }, {\n      key: \"setDescribedByIds\",\n      value: function setDescribedByIds(ids) {\n        if (ids.length) {\n          this._elementRef.nativeElement.setAttribute('aria-describedby', ids.join(' '));\n        } else {\n          this._elementRef.nativeElement.removeAttribute('aria-describedby');\n        }\n      }\n      /**\n       * Implemented as part of MatFormFieldControl.\n       * @docs-private\n       */\n\n    }, {\n      key: \"onContainerClick\",\n      value: function onContainerClick() {\n        // Do not re-focus the input element if the element is already focused. Otherwise it can happen\n        // that someone clicks on a time input and the cursor resets to the \"hours\" field while the\n        // \"minutes\" field was actually clicked. See: https://github.com/angular/components/issues/12849\n        if (!this.focused) {\n          this.focus();\n        }\n      }\n      /** Whether the form control is a native select that is displayed inline. */\n\n    }, {\n      key: \"_isInlineSelect\",\n      value: function _isInlineSelect() {\n        var element = this._elementRef.nativeElement;\n        return this._isNativeSelect && (element.multiple || element.size > 1);\n      }\n    }]);\n\n    return MatInput;\n  }(_MatInputBase);\n\n  MatInput.ɵfac = function MatInput_Factory(t) {\n    return new (t || MatInput)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i1.Platform), i0.ɵɵdirectiveInject(i2.NgControl, 10), i0.ɵɵdirectiveInject(i2.NgForm, 8), i0.ɵɵdirectiveInject(i2.FormGroupDirective, 8), i0.ɵɵdirectiveInject(i3.ErrorStateMatcher), i0.ɵɵdirectiveInject(MAT_INPUT_VALUE_ACCESSOR, 10), i0.ɵɵdirectiveInject(i4.AutofillMonitor), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(MAT_FORM_FIELD, 8));\n  };\n\n  MatInput.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: MatInput,\n    selectors: [[\"input\", \"matInput\", \"\"], [\"textarea\", \"matInput\", \"\"], [\"select\", \"matNativeControl\", \"\"], [\"input\", \"matNativeControl\", \"\"], [\"textarea\", \"matNativeControl\", \"\"]],\n    hostAttrs: [1, \"mat-input-element\", \"mat-form-field-autofill-control\"],\n    hostVars: 11,\n    hostBindings: function MatInput_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"focus\", function MatInput_focus_HostBindingHandler() {\n          return ctx._focusChanged(true);\n        })(\"blur\", function MatInput_blur_HostBindingHandler() {\n          return ctx._focusChanged(false);\n        })(\"input\", function MatInput_input_HostBindingHandler() {\n          return ctx._onInput();\n        });\n      }\n\n      if (rf & 2) {\n        i0.ɵɵhostProperty(\"disabled\", ctx.disabled)(\"required\", ctx.required);\n        i0.ɵɵattribute(\"id\", ctx.id)(\"data-placeholder\", ctx.placeholder)(\"readonly\", ctx.readonly && !ctx._isNativeSelect || null)(\"aria-invalid\", ctx.empty && ctx.required ? null : ctx.errorState)(\"aria-required\", ctx.required);\n        i0.ɵɵclassProp(\"mat-input-server\", ctx._isServer)(\"mat-native-select-inline\", ctx._isInlineSelect());\n      }\n    },\n    inputs: {\n      disabled: \"disabled\",\n      id: \"id\",\n      placeholder: \"placeholder\",\n      required: \"required\",\n      type: \"type\",\n      errorStateMatcher: \"errorStateMatcher\",\n      userAriaDescribedBy: [\"aria-describedby\", \"userAriaDescribedBy\"],\n      value: \"value\",\n      readonly: \"readonly\"\n    },\n    exportAs: [\"matInput\"],\n    features: [i0.ɵɵProvidersFeature([{\n      provide: MatFormFieldControl,\n      useExisting: MatInput\n    }]), i0.ɵɵInheritDefinitionFeature, i0.ɵɵNgOnChangesFeature]\n  });\n  return MatInput;\n})();\n\n/*#__PURE__*/\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nvar MatInputModule = /*#__PURE__*/(function () {\n  var MatInputModule = /*#__PURE__*/_createClass(function MatInputModule() {\n    _classCallCheck(this, MatInputModule);\n  });\n\n  MatInputModule.ɵfac = function MatInputModule_Factory(t) {\n    return new (t || MatInputModule)();\n  };\n\n  MatInputModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: MatInputModule\n  });\n  MatInputModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    providers: [ErrorStateMatcher],\n    imports: [[TextFieldModule, MatFormFieldModule, MatCommonModule], TextFieldModule, // We re-export the `MatFormFieldModule` since `MatInput` will almost always\n    // be used together with `MatFormField`.\n    MatFormFieldModule]\n  });\n  return MatInputModule;\n})();\n\n/*#__PURE__*/\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { MAT_INPUT_VALUE_ACCESSOR, MatInput, MatInputModule, getMatInputUnsupportedTypeError }; //# sourceMappingURL=input.mjs.map","map":null,"metadata":{},"sourceType":"module"}