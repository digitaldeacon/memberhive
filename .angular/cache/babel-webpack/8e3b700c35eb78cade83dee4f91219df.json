{"ast":null,"code":"import _slicedToArray from \"/Applications/MAMP/htdocs/memberhive/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _inherits from \"/Applications/MAMP/htdocs/memberhive/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Applications/MAMP/htdocs/memberhive/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport _toConsumableArray from \"/Applications/MAMP/htdocs/memberhive/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _createClass from \"/Applications/MAMP/htdocs/memberhive/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _classCallCheck from \"/Applications/MAMP/htdocs/memberhive/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport * as i0 from '@angular/core';\nimport { InjectionToken, Injectable, Inject, NgModule } from '@angular/core';\nimport * as i2 from '@ngrx/store';\nimport { INIT, UPDATE, ActionsSubject, INITIAL_STATE, StateObservable, ReducerManagerDispatcher } from '@ngrx/store';\nimport { EMPTY, Observable, of, merge, queueScheduler, ReplaySubject } from 'rxjs';\nimport { share, filter, map, concatMap, timeout, debounceTime, catchError, take, takeUntil, switchMap, skip, observeOn, withLatestFrom, scan } from 'rxjs/operators';\n/**\n * Chrome extension documentation\n * @see https://github.com/reduxjs/redux-devtools/blob/main/extension/docs/API/Arguments.md\n * Firefox extension documentation\n * @see https://github.com/zalmoxisus/redux-devtools-extension/blob/master/docs/API/Arguments.md\n */\n\nvar StoreDevtoolsConfig = /*#__PURE__*/_createClass(function StoreDevtoolsConfig() {\n  _classCallCheck(this, StoreDevtoolsConfig);\n\n  /**\n   * Maximum allowed actions to be stored in the history tree (default: `false`)\n   */\n  this.maxAge = false;\n});\n\nvar STORE_DEVTOOLS_CONFIG = new InjectionToken('@ngrx/store-devtools Options');\n/**\n * Used to provide a `StoreDevtoolsConfig` for the store-devtools.\n */\n\nvar INITIAL_OPTIONS = new InjectionToken('@ngrx/store-devtools Initial Config');\n\nfunction noMonitor() {\n  return null;\n}\n\nvar DEFAULT_NAME = 'NgRx Store DevTools';\n\nfunction createConfig(optionsInput) {\n  var DEFAULT_OPTIONS = {\n    maxAge: false,\n    monitor: noMonitor,\n    actionSanitizer: undefined,\n    stateSanitizer: undefined,\n    name: DEFAULT_NAME,\n    serialize: false,\n    logOnly: false,\n    autoPause: false,\n    // Add all features explicitly. This prevent buggy behavior for\n    // options like \"lock\" which might otherwise not show up.\n    features: {\n      pause: true,\n      lock: true,\n      persist: true,\n      export: true,\n      import: 'custom',\n      jump: true,\n      skip: true,\n      reorder: true,\n      dispatch: true,\n      test: true // Generate tests for the selected actions\n\n    }\n  };\n  var options = typeof optionsInput === 'function' ? optionsInput() : optionsInput;\n  var logOnly = options.logOnly ? {\n    pause: true,\n    export: true,\n    test: true\n  } : false;\n  var features = options.features || logOnly || DEFAULT_OPTIONS.features;\n  var config = Object.assign({}, DEFAULT_OPTIONS, {\n    features: features\n  }, options);\n\n  if (config.maxAge && config.maxAge < 2) {\n    throw new Error(\"Devtools 'maxAge' cannot be less than 2, got \".concat(config.maxAge));\n  }\n\n  return config;\n}\n\nvar PERFORM_ACTION = 'PERFORM_ACTION';\nvar REFRESH = 'REFRESH';\nvar RESET = 'RESET';\nvar ROLLBACK = 'ROLLBACK';\nvar COMMIT = 'COMMIT';\nvar SWEEP = 'SWEEP';\nvar TOGGLE_ACTION = 'TOGGLE_ACTION';\nvar SET_ACTIONS_ACTIVE = 'SET_ACTIONS_ACTIVE';\nvar JUMP_TO_STATE = 'JUMP_TO_STATE';\nvar JUMP_TO_ACTION = 'JUMP_TO_ACTION';\nvar IMPORT_STATE = 'IMPORT_STATE';\nvar LOCK_CHANGES = 'LOCK_CHANGES';\nvar PAUSE_RECORDING = 'PAUSE_RECORDING';\n\nvar PerformAction = /*#__PURE__*/_createClass(function PerformAction(action, timestamp) {\n  _classCallCheck(this, PerformAction);\n\n  this.action = action;\n  this.timestamp = timestamp;\n  this.type = PERFORM_ACTION;\n\n  if (typeof action.type === 'undefined') {\n    throw new Error('Actions may not have an undefined \"type\" property. ' + 'Have you misspelled a constant?');\n  }\n});\n\nvar Refresh = /*#__PURE__*/_createClass(function Refresh() {\n  _classCallCheck(this, Refresh);\n\n  this.type = REFRESH;\n});\n\nvar Reset = /*#__PURE__*/_createClass(function Reset(timestamp) {\n  _classCallCheck(this, Reset);\n\n  this.timestamp = timestamp;\n  this.type = RESET;\n});\n\nvar Rollback = /*#__PURE__*/_createClass(function Rollback(timestamp) {\n  _classCallCheck(this, Rollback);\n\n  this.timestamp = timestamp;\n  this.type = ROLLBACK;\n});\n\nvar Commit = /*#__PURE__*/_createClass(function Commit(timestamp) {\n  _classCallCheck(this, Commit);\n\n  this.timestamp = timestamp;\n  this.type = COMMIT;\n});\n\nvar Sweep = /*#__PURE__*/_createClass(function Sweep() {\n  _classCallCheck(this, Sweep);\n\n  this.type = SWEEP;\n});\n\nvar ToggleAction = /*#__PURE__*/_createClass(function ToggleAction(id) {\n  _classCallCheck(this, ToggleAction);\n\n  this.id = id;\n  this.type = TOGGLE_ACTION;\n});\n\nvar SetActionsActive = /*#__PURE__*/_createClass(function SetActionsActive(start, end) {\n  var active = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n\n  _classCallCheck(this, SetActionsActive);\n\n  this.start = start;\n  this.end = end;\n  this.active = active;\n  this.type = SET_ACTIONS_ACTIVE;\n});\n\nvar JumpToState = /*#__PURE__*/_createClass(function JumpToState(index) {\n  _classCallCheck(this, JumpToState);\n\n  this.index = index;\n  this.type = JUMP_TO_STATE;\n});\n\nvar JumpToAction = /*#__PURE__*/_createClass(function JumpToAction(actionId) {\n  _classCallCheck(this, JumpToAction);\n\n  this.actionId = actionId;\n  this.type = JUMP_TO_ACTION;\n});\n\nvar ImportState = /*#__PURE__*/_createClass(function ImportState(nextLiftedState) {\n  _classCallCheck(this, ImportState);\n\n  this.nextLiftedState = nextLiftedState;\n  this.type = IMPORT_STATE;\n});\n\nvar LockChanges = /*#__PURE__*/_createClass(function LockChanges(status) {\n  _classCallCheck(this, LockChanges);\n\n  this.status = status;\n  this.type = LOCK_CHANGES;\n});\n\nvar PauseRecording = /*#__PURE__*/_createClass(function PauseRecording(status) {\n  _classCallCheck(this, PauseRecording);\n\n  this.status = status;\n  this.type = PAUSE_RECORDING;\n});\n\nfunction difference(first, second) {\n  return first.filter(function (item) {\n    return second.indexOf(item) < 0;\n  });\n}\n/**\n * Provides an app's view into the state of the lifted store.\n */\n\n\nfunction unliftState(liftedState) {\n  var computedStates = liftedState.computedStates,\n      currentStateIndex = liftedState.currentStateIndex; // At start up NgRx dispatches init actions,\n  // When these init actions are being filtered out by the predicate or safe/block list options\n  // we don't have a complete computed states yet.\n  // At this point it could happen that we're out of bounds, when this happens we fall back to the last known state\n\n  if (currentStateIndex >= computedStates.length) {\n    var _state = computedStates[computedStates.length - 1].state;\n    return _state;\n  }\n\n  var state = computedStates[currentStateIndex].state;\n  return state;\n}\n\nfunction unliftAction(liftedState) {\n  return liftedState.actionsById[liftedState.nextActionId - 1];\n}\n/**\n * Lifts an app's action into an action on the lifted store.\n */\n\n\nfunction liftAction(action) {\n  return new PerformAction(action, +Date.now());\n}\n/**\n * Sanitizes given actions with given function.\n */\n\n\nfunction sanitizeActions(actionSanitizer, actions) {\n  return Object.keys(actions).reduce(function (sanitizedActions, actionIdx) {\n    var idx = Number(actionIdx);\n    sanitizedActions[idx] = sanitizeAction(actionSanitizer, actions[idx], idx);\n    return sanitizedActions;\n  }, {});\n}\n/**\n * Sanitizes given action with given function.\n */\n\n\nfunction sanitizeAction(actionSanitizer, action, actionIdx) {\n  return Object.assign(Object.assign({}, action), {\n    action: actionSanitizer(action.action, actionIdx)\n  });\n}\n/**\n * Sanitizes given states with given function.\n */\n\n\nfunction sanitizeStates(stateSanitizer, states) {\n  return states.map(function (computedState, idx) {\n    return {\n      state: sanitizeState(stateSanitizer, computedState.state, idx),\n      error: computedState.error\n    };\n  });\n}\n/**\n * Sanitizes given state with given function.\n */\n\n\nfunction sanitizeState(stateSanitizer, state, stateIdx) {\n  return stateSanitizer(state, stateIdx);\n}\n/**\n * Read the config and tell if actions should be filtered\n */\n\n\nfunction shouldFilterActions(config) {\n  return config.predicate || config.actionsSafelist || config.actionsBlocklist;\n}\n/**\n * Return a full filtered lifted state\n */\n\n\nfunction filterLiftedState(liftedState, predicate, safelist, blocklist) {\n  var filteredStagedActionIds = [];\n  var filteredActionsById = {};\n  var filteredComputedStates = [];\n  liftedState.stagedActionIds.forEach(function (id, idx) {\n    var liftedAction = liftedState.actionsById[id];\n    if (!liftedAction) return;\n\n    if (idx && isActionFiltered(liftedState.computedStates[idx], liftedAction, predicate, safelist, blocklist)) {\n      return;\n    }\n\n    filteredActionsById[id] = liftedAction;\n    filteredStagedActionIds.push(id);\n    filteredComputedStates.push(liftedState.computedStates[idx]);\n  });\n  return Object.assign(Object.assign({}, liftedState), {\n    stagedActionIds: filteredStagedActionIds,\n    actionsById: filteredActionsById,\n    computedStates: filteredComputedStates\n  });\n}\n/**\n * Return true is the action should be ignored\n */\n\n\nfunction isActionFiltered(state, action, predicate, safelist, blockedlist) {\n  var predicateMatch = predicate && !predicate(state, action.action);\n  var safelistMatch = safelist && !action.action.type.match(safelist.map(function (s) {\n    return escapeRegExp(s);\n  }).join('|'));\n  var blocklistMatch = blockedlist && action.action.type.match(blockedlist.map(function (s) {\n    return escapeRegExp(s);\n  }).join('|'));\n  return predicateMatch || safelistMatch || blocklistMatch;\n}\n/**\n * Return string with escaped RegExp special characters\n * https://stackoverflow.com/a/6969486/1337347\n */\n\n\nfunction escapeRegExp(s) {\n  return s.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n}\n\nvar INIT_ACTION = {\n  type: INIT\n};\nvar RECOMPUTE = '@ngrx/store-devtools/recompute';\nvar RECOMPUTE_ACTION = {\n  type: RECOMPUTE\n};\n/**\n * Computes the next entry in the log by applying an action.\n */\n\nfunction computeNextEntry(reducer, action, state, error, errorHandler) {\n  if (error) {\n    return {\n      state: state,\n      error: 'Interrupted by an error up the chain'\n    };\n  }\n\n  var nextState = state;\n  var nextError;\n\n  try {\n    nextState = reducer(state, action);\n  } catch (err) {\n    nextError = err.toString();\n    errorHandler.handleError(err);\n  }\n\n  return {\n    state: nextState,\n    error: nextError\n  };\n}\n/**\n * Runs the reducer on invalidated actions to get a fresh computation log.\n */\n\n\nfunction recomputeStates(computedStates, minInvalidatedStateIndex, reducer, committedState, actionsById, stagedActionIds, skippedActionIds, errorHandler, isPaused) {\n  // Optimization: exit early and return the same reference\n  // if we know nothing could have changed.\n  if (minInvalidatedStateIndex >= computedStates.length && computedStates.length === stagedActionIds.length) {\n    return computedStates;\n  }\n\n  var nextComputedStates = computedStates.slice(0, minInvalidatedStateIndex); // If the recording is paused, recompute all states up until the pause state,\n  // else recompute all states.\n\n  var lastIncludedActionId = stagedActionIds.length - (isPaused ? 1 : 0);\n\n  for (var i = minInvalidatedStateIndex; i < lastIncludedActionId; i++) {\n    var actionId = stagedActionIds[i];\n    var action = actionsById[actionId].action;\n    var previousEntry = nextComputedStates[i - 1];\n    var previousState = previousEntry ? previousEntry.state : committedState;\n    var previousError = previousEntry ? previousEntry.error : undefined;\n    var shouldSkip = skippedActionIds.indexOf(actionId) > -1;\n    var entry = shouldSkip ? previousEntry : computeNextEntry(reducer, action, previousState, previousError, errorHandler);\n    nextComputedStates.push(entry);\n  } // If the recording is paused, the last state will not be recomputed,\n  // because it's essentially not part of the state history.\n\n\n  if (isPaused) {\n    nextComputedStates.push(computedStates[computedStates.length - 1]);\n  }\n\n  return nextComputedStates;\n}\n\nfunction liftInitialState(initialCommittedState, monitorReducer) {\n  return {\n    monitorState: monitorReducer(undefined, {}),\n    nextActionId: 1,\n    actionsById: {\n      0: liftAction(INIT_ACTION)\n    },\n    stagedActionIds: [0],\n    skippedActionIds: [],\n    committedState: initialCommittedState,\n    currentStateIndex: 0,\n    computedStates: [],\n    isLocked: false,\n    isPaused: false\n  };\n}\n/**\n * Creates a history state reducer from an app's reducer.\n */\n\n\nfunction liftReducerWith(initialCommittedState, initialLiftedState, errorHandler, monitorReducer) {\n  var options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n\n  /**\n   * Manages how the history actions modify the history state.\n   */\n  return function (reducer) {\n    return function (liftedState, liftedAction) {\n      var _ref = liftedState || initialLiftedState,\n          monitorState = _ref.monitorState,\n          actionsById = _ref.actionsById,\n          nextActionId = _ref.nextActionId,\n          stagedActionIds = _ref.stagedActionIds,\n          skippedActionIds = _ref.skippedActionIds,\n          committedState = _ref.committedState,\n          currentStateIndex = _ref.currentStateIndex,\n          computedStates = _ref.computedStates,\n          isLocked = _ref.isLocked,\n          isPaused = _ref.isPaused;\n\n      if (!liftedState) {\n        // Prevent mutating initialLiftedState\n        actionsById = Object.create(actionsById);\n      }\n\n      function commitExcessActions(n) {\n        // Auto-commits n-number of excess actions.\n        var excess = n;\n        var idsToDelete = stagedActionIds.slice(1, excess + 1);\n\n        for (var i = 0; i < idsToDelete.length; i++) {\n          if (computedStates[i + 1].error) {\n            // Stop if error is found. Commit actions up to error.\n            excess = i;\n            idsToDelete = stagedActionIds.slice(1, excess + 1);\n            break;\n          } else {\n            delete actionsById[idsToDelete[i]];\n          }\n        }\n\n        skippedActionIds = skippedActionIds.filter(function (id) {\n          return idsToDelete.indexOf(id) === -1;\n        });\n        stagedActionIds = [0].concat(_toConsumableArray(stagedActionIds.slice(excess + 1)));\n        committedState = computedStates[excess].state;\n        computedStates = computedStates.slice(excess);\n        currentStateIndex = currentStateIndex > excess ? currentStateIndex - excess : 0;\n      }\n\n      function commitChanges() {\n        // Consider the last committed state the new starting point.\n        // Squash any staged actions into a single committed state.\n        actionsById = {\n          0: liftAction(INIT_ACTION)\n        };\n        nextActionId = 1;\n        stagedActionIds = [0];\n        skippedActionIds = [];\n        committedState = computedStates[currentStateIndex].state;\n        currentStateIndex = 0;\n        computedStates = [];\n      } // By default, aggressively recompute every state whatever happens.\n      // This has O(n) performance, so we'll override this to a sensible\n      // value whenever we feel like we don't have to recompute the states.\n\n\n      var minInvalidatedStateIndex = 0;\n\n      switch (liftedAction.type) {\n        case LOCK_CHANGES:\n          {\n            isLocked = liftedAction.status;\n            minInvalidatedStateIndex = Infinity;\n            break;\n          }\n\n        case PAUSE_RECORDING:\n          {\n            isPaused = liftedAction.status;\n\n            if (isPaused) {\n              // Add a pause action to signal the devtools-user the recording is paused.\n              // The corresponding state will be overwritten on each update to always contain\n              // the latest state (see Actions.PERFORM_ACTION).\n              stagedActionIds = [].concat(_toConsumableArray(stagedActionIds), [nextActionId]);\n              actionsById[nextActionId] = new PerformAction({\n                type: '@ngrx/devtools/pause'\n              }, +Date.now());\n              nextActionId++;\n              minInvalidatedStateIndex = stagedActionIds.length - 1;\n              computedStates = computedStates.concat(computedStates[computedStates.length - 1]);\n\n              if (currentStateIndex === stagedActionIds.length - 2) {\n                currentStateIndex++;\n              }\n\n              minInvalidatedStateIndex = Infinity;\n            } else {\n              commitChanges();\n            }\n\n            break;\n          }\n\n        case RESET:\n          {\n            // Get back to the state the store was created with.\n            actionsById = {\n              0: liftAction(INIT_ACTION)\n            };\n            nextActionId = 1;\n            stagedActionIds = [0];\n            skippedActionIds = [];\n            committedState = initialCommittedState;\n            currentStateIndex = 0;\n            computedStates = [];\n            break;\n          }\n\n        case COMMIT:\n          {\n            commitChanges();\n            break;\n          }\n\n        case ROLLBACK:\n          {\n            // Forget about any staged actions.\n            // Start again from the last committed state.\n            actionsById = {\n              0: liftAction(INIT_ACTION)\n            };\n            nextActionId = 1;\n            stagedActionIds = [0];\n            skippedActionIds = [];\n            currentStateIndex = 0;\n            computedStates = [];\n            break;\n          }\n\n        case TOGGLE_ACTION:\n          {\n            // Toggle whether an action with given ID is skipped.\n            // Being skipped means it is a no-op during the computation.\n            var actionId = liftedAction.id;\n            var index = skippedActionIds.indexOf(actionId);\n\n            if (index === -1) {\n              skippedActionIds = [actionId].concat(_toConsumableArray(skippedActionIds));\n            } else {\n              skippedActionIds = skippedActionIds.filter(function (id) {\n                return id !== actionId;\n              });\n            } // Optimization: we know history before this action hasn't changed\n\n\n            minInvalidatedStateIndex = stagedActionIds.indexOf(actionId);\n            break;\n          }\n\n        case SET_ACTIONS_ACTIVE:\n          {\n            // Toggle whether an action with given ID is skipped.\n            // Being skipped means it is a no-op during the computation.\n            var start = liftedAction.start,\n                end = liftedAction.end,\n                active = liftedAction.active;\n            var actionIds = [];\n\n            for (var i = start; i < end; i++) {\n              actionIds.push(i);\n            }\n\n            if (active) {\n              skippedActionIds = difference(skippedActionIds, actionIds);\n            } else {\n              skippedActionIds = [].concat(_toConsumableArray(skippedActionIds), actionIds);\n            } // Optimization: we know history before this action hasn't changed\n\n\n            minInvalidatedStateIndex = stagedActionIds.indexOf(start);\n            break;\n          }\n\n        case JUMP_TO_STATE:\n          {\n            // Without recomputing anything, move the pointer that tell us\n            // which state is considered the current one. Useful for sliders.\n            currentStateIndex = liftedAction.index; // Optimization: we know the history has not changed.\n\n            minInvalidatedStateIndex = Infinity;\n            break;\n          }\n\n        case JUMP_TO_ACTION:\n          {\n            // Jumps to a corresponding state to a specific action.\n            // Useful when filtering actions.\n            var _index = stagedActionIds.indexOf(liftedAction.actionId);\n\n            if (_index !== -1) currentStateIndex = _index;\n            minInvalidatedStateIndex = Infinity;\n            break;\n          }\n\n        case SWEEP:\n          {\n            // Forget any actions that are currently being skipped.\n            stagedActionIds = difference(stagedActionIds, skippedActionIds);\n            skippedActionIds = [];\n            currentStateIndex = Math.min(currentStateIndex, stagedActionIds.length - 1);\n            break;\n          }\n\n        case PERFORM_ACTION:\n          {\n            // Ignore action and return state as is if recording is locked\n            if (isLocked) {\n              return liftedState || initialLiftedState;\n            }\n\n            if (isPaused || liftedState && isActionFiltered(liftedState.computedStates[currentStateIndex], liftedAction, options.predicate, options.actionsSafelist, options.actionsBlocklist)) {\n              // If recording is paused or if the action should be ignored, overwrite the last state\n              // (corresponds to the pause action) and keep everything else as is.\n              // This way, the app gets the new current state while the devtools\n              // do not record another action.\n              var lastState = computedStates[computedStates.length - 1];\n              computedStates = [].concat(_toConsumableArray(computedStates.slice(0, -1)), [computeNextEntry(reducer, liftedAction.action, lastState.state, lastState.error, errorHandler)]);\n              minInvalidatedStateIndex = Infinity;\n              break;\n            } // Auto-commit as new actions come in.\n\n\n            if (options.maxAge && stagedActionIds.length === options.maxAge) {\n              commitExcessActions(1);\n            }\n\n            if (currentStateIndex === stagedActionIds.length - 1) {\n              currentStateIndex++;\n            }\n\n            var _actionId = nextActionId++; // Mutation! This is the hottest path, and we optimize on purpose.\n            // It is safe because we set a new key in a cache dictionary.\n\n\n            actionsById[_actionId] = liftedAction;\n            stagedActionIds = [].concat(_toConsumableArray(stagedActionIds), [_actionId]); // Optimization: we know that only the new action needs computing.\n\n            minInvalidatedStateIndex = stagedActionIds.length - 1;\n            break;\n          }\n\n        case IMPORT_STATE:\n          {\n            // Completely replace everything.\n            var _liftedAction$nextLif = liftedAction.nextLiftedState;\n            monitorState = _liftedAction$nextLif.monitorState;\n            actionsById = _liftedAction$nextLif.actionsById;\n            nextActionId = _liftedAction$nextLif.nextActionId;\n            stagedActionIds = _liftedAction$nextLif.stagedActionIds;\n            skippedActionIds = _liftedAction$nextLif.skippedActionIds;\n            committedState = _liftedAction$nextLif.committedState;\n            currentStateIndex = _liftedAction$nextLif.currentStateIndex;\n            computedStates = _liftedAction$nextLif.computedStates;\n            isLocked = _liftedAction$nextLif.isLocked;\n            isPaused = _liftedAction$nextLif.isPaused;\n            break;\n          }\n\n        case INIT:\n          {\n            // Always recompute states on hot reload and init.\n            minInvalidatedStateIndex = 0;\n\n            if (options.maxAge && stagedActionIds.length > options.maxAge) {\n              // States must be recomputed before committing excess.\n              computedStates = recomputeStates(computedStates, minInvalidatedStateIndex, reducer, committedState, actionsById, stagedActionIds, skippedActionIds, errorHandler, isPaused);\n              commitExcessActions(stagedActionIds.length - options.maxAge); // Avoid double computation.\n\n              minInvalidatedStateIndex = Infinity;\n            }\n\n            break;\n          }\n\n        case UPDATE:\n          {\n            var stateHasErrors = computedStates.filter(function (state) {\n              return state.error;\n            }).length > 0;\n\n            if (stateHasErrors) {\n              // Recompute all states\n              minInvalidatedStateIndex = 0;\n\n              if (options.maxAge && stagedActionIds.length > options.maxAge) {\n                // States must be recomputed before committing excess.\n                computedStates = recomputeStates(computedStates, minInvalidatedStateIndex, reducer, committedState, actionsById, stagedActionIds, skippedActionIds, errorHandler, isPaused);\n                commitExcessActions(stagedActionIds.length - options.maxAge); // Avoid double computation.\n\n                minInvalidatedStateIndex = Infinity;\n              }\n            } else {\n              // If not paused/locked, add a new action to signal devtools-user\n              // that there was a reducer update.\n              if (!isPaused && !isLocked) {\n                if (currentStateIndex === stagedActionIds.length - 1) {\n                  currentStateIndex++;\n                } // Add a new action to only recompute state\n\n\n                var _actionId2 = nextActionId++;\n\n                actionsById[_actionId2] = new PerformAction(liftedAction, +Date.now());\n                stagedActionIds = [].concat(_toConsumableArray(stagedActionIds), [_actionId2]);\n                minInvalidatedStateIndex = stagedActionIds.length - 1;\n                computedStates = recomputeStates(computedStates, minInvalidatedStateIndex, reducer, committedState, actionsById, stagedActionIds, skippedActionIds, errorHandler, isPaused);\n              } // Recompute state history with latest reducer and update action\n\n\n              computedStates = computedStates.map(function (cmp) {\n                return Object.assign(Object.assign({}, cmp), {\n                  state: reducer(cmp.state, RECOMPUTE_ACTION)\n                });\n              });\n              currentStateIndex = stagedActionIds.length - 1;\n\n              if (options.maxAge && stagedActionIds.length > options.maxAge) {\n                commitExcessActions(stagedActionIds.length - options.maxAge);\n              } // Avoid double computation.\n\n\n              minInvalidatedStateIndex = Infinity;\n            }\n\n            break;\n          }\n\n        default:\n          {\n            // If the action is not recognized, it's a monitor action.\n            // Optimization: a monitor action can't change history.\n            minInvalidatedStateIndex = Infinity;\n            break;\n          }\n      }\n\n      computedStates = recomputeStates(computedStates, minInvalidatedStateIndex, reducer, committedState, actionsById, stagedActionIds, skippedActionIds, errorHandler, isPaused);\n      monitorState = monitorReducer(monitorState, liftedAction);\n      return {\n        monitorState: monitorState,\n        actionsById: actionsById,\n        nextActionId: nextActionId,\n        stagedActionIds: stagedActionIds,\n        skippedActionIds: skippedActionIds,\n        committedState: committedState,\n        currentStateIndex: currentStateIndex,\n        computedStates: computedStates,\n        isLocked: isLocked,\n        isPaused: isPaused\n      };\n    };\n  };\n}\n\nvar DevtoolsDispatcher = /*#__PURE__*/(function () {\n  var DevtoolsDispatcher = /*#__PURE__*/function (_ActionsSubject) {\n    _inherits(DevtoolsDispatcher, _ActionsSubject);\n\n    var _super = _createSuper(DevtoolsDispatcher);\n\n    function DevtoolsDispatcher() {\n      _classCallCheck(this, DevtoolsDispatcher);\n\n      return _super.apply(this, arguments);\n    }\n\n    return _createClass(DevtoolsDispatcher);\n  }(ActionsSubject);\n\n  /** @nocollapse */\n\n  /** @nocollapse */\n  DevtoolsDispatcher.ɵfac = /* @__PURE__ */function () {\n    var ɵDevtoolsDispatcher_BaseFactory;\n    return function DevtoolsDispatcher_Factory(t) {\n      return (ɵDevtoolsDispatcher_BaseFactory || (ɵDevtoolsDispatcher_BaseFactory = i0.ɵɵgetInheritedFactory(DevtoolsDispatcher)))(t || DevtoolsDispatcher);\n    };\n  }();\n  /** @nocollapse */\n\n  /** @nocollapse */\n\n\n  DevtoolsDispatcher.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: DevtoolsDispatcher,\n    factory: DevtoolsDispatcher.ɵfac\n  });\n  return DevtoolsDispatcher;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nvar ExtensionActionTypes = {\n  START: 'START',\n  DISPATCH: 'DISPATCH',\n  STOP: 'STOP',\n  ACTION: 'ACTION'\n};\nvar REDUX_DEVTOOLS_EXTENSION = new InjectionToken('@ngrx/store-devtools Redux Devtools Extension');\nvar DevtoolsExtension = /*#__PURE__*/(function () {\n  var DevtoolsExtension = /*#__PURE__*/function () {\n    function DevtoolsExtension(devtoolsExtension, config, dispatcher) {\n      _classCallCheck(this, DevtoolsExtension);\n\n      this.config = config;\n      this.dispatcher = dispatcher;\n      this.devtoolsExtension = devtoolsExtension;\n      this.createActionStreams();\n    }\n\n    _createClass(DevtoolsExtension, [{\n      key: \"notify\",\n      value: function notify(action, state) {\n        var _this = this;\n\n        if (!this.devtoolsExtension) {\n          return;\n        } // Check to see if the action requires a full update of the liftedState.\n        // If it is a simple action generated by the user's app and the recording\n        // is not locked/paused, only send the action and the current state (fast).\n        //\n        // A full liftedState update (slow: serializes the entire liftedState) is\n        // only required when:\n        //   a) redux-devtools-extension fires the @@Init action (ignored by\n        //      @ngrx/store-devtools)\n        //   b) an action is generated by an @ngrx module (e.g. @ngrx/effects/init\n        //      or @ngrx/store/update-reducers)\n        //   c) the state has been recomputed due to time-traveling\n        //   d) any action that is not a PerformAction to err on the side of\n        //      caution.\n\n\n        if (action.type === PERFORM_ACTION) {\n          if (state.isLocked || state.isPaused) {\n            return;\n          }\n\n          var currentState = unliftState(state);\n\n          if (shouldFilterActions(this.config) && isActionFiltered(currentState, action, this.config.predicate, this.config.actionsSafelist, this.config.actionsBlocklist)) {\n            return;\n          }\n\n          var sanitizedState = this.config.stateSanitizer ? sanitizeState(this.config.stateSanitizer, currentState, state.currentStateIndex) : currentState;\n          var sanitizedAction = this.config.actionSanitizer ? sanitizeAction(this.config.actionSanitizer, action, state.nextActionId) : action;\n          this.sendToReduxDevtools(function () {\n            return _this.extensionConnection.send(sanitizedAction, sanitizedState);\n          });\n        } else {\n          // Requires full state update\n          var sanitizedLiftedState = Object.assign(Object.assign({}, state), {\n            stagedActionIds: state.stagedActionIds,\n            actionsById: this.config.actionSanitizer ? sanitizeActions(this.config.actionSanitizer, state.actionsById) : state.actionsById,\n            computedStates: this.config.stateSanitizer ? sanitizeStates(this.config.stateSanitizer, state.computedStates) : state.computedStates\n          });\n          this.sendToReduxDevtools(function () {\n            return _this.devtoolsExtension.send(null, sanitizedLiftedState, _this.getExtensionConfig(_this.config));\n          });\n        }\n      }\n    }, {\n      key: \"createChangesObservable\",\n      value: function createChangesObservable() {\n        var _this2 = this;\n\n        if (!this.devtoolsExtension) {\n          return EMPTY;\n        }\n\n        return new Observable(function (subscriber) {\n          var connection = _this2.devtoolsExtension.connect(_this2.getExtensionConfig(_this2.config));\n\n          _this2.extensionConnection = connection;\n          connection.init();\n          connection.subscribe(function (change) {\n            return subscriber.next(change);\n          });\n          return connection.unsubscribe;\n        });\n      }\n    }, {\n      key: \"createActionStreams\",\n      value: function createActionStreams() {\n        var _this3 = this;\n\n        // Listens to all changes\n        var changes$ = this.createChangesObservable().pipe(share()); // Listen for the start action\n\n        var start$ = changes$.pipe(filter(function (change) {\n          return change.type === ExtensionActionTypes.START;\n        })); // Listen for the stop action\n\n        var stop$ = changes$.pipe(filter(function (change) {\n          return change.type === ExtensionActionTypes.STOP;\n        })); // Listen for lifted actions\n\n        var liftedActions$ = changes$.pipe(filter(function (change) {\n          return change.type === ExtensionActionTypes.DISPATCH;\n        }), map(function (change) {\n          return _this3.unwrapAction(change.payload);\n        }), concatMap(function (action) {\n          if (action.type === IMPORT_STATE) {\n            // State imports may happen in two situations:\n            // 1. Explicitly by user\n            // 2. User activated the \"persist state accross reloads\" option\n            //    and now the state is imported during reload.\n            // Because of option 2, we need to give possible\n            // lazy loaded reducers time to instantiate.\n            // As soon as there is no UPDATE action within 1 second,\n            // it is assumed that all reducers are loaded.\n            return _this3.dispatcher.pipe(filter(function (action) {\n              return action.type === UPDATE;\n            }), timeout(1000), debounceTime(1000), map(function () {\n              return action;\n            }), catchError(function () {\n              return of(action);\n            }), take(1));\n          } else {\n            return of(action);\n          }\n        })); // Listen for unlifted actions\n\n        var actions$ = changes$.pipe(filter(function (change) {\n          return change.type === ExtensionActionTypes.ACTION;\n        }), map(function (change) {\n          return _this3.unwrapAction(change.payload);\n        }));\n        var actionsUntilStop$ = actions$.pipe(takeUntil(stop$));\n        var liftedUntilStop$ = liftedActions$.pipe(takeUntil(stop$));\n        this.start$ = start$.pipe(takeUntil(stop$)); // Only take the action sources between the start/stop events\n\n        this.actions$ = this.start$.pipe(switchMap(function () {\n          return actionsUntilStop$;\n        }));\n        this.liftedActions$ = this.start$.pipe(switchMap(function () {\n          return liftedUntilStop$;\n        }));\n      }\n    }, {\n      key: \"unwrapAction\",\n      value: function unwrapAction(action) {\n        return typeof action === 'string' ? eval(\"(\".concat(action, \")\")) : action;\n      }\n    }, {\n      key: \"getExtensionConfig\",\n      value: function getExtensionConfig(config) {\n        var _a;\n\n        var extensionOptions = {\n          name: config.name,\n          features: config.features,\n          serialize: config.serialize,\n          autoPause: (_a = config.autoPause) !== null && _a !== void 0 ? _a : false // The action/state sanitizers are not added to the config\n          // because sanitation is done in this class already.\n          // It is done before sending it to the devtools extension for consistency:\n          // - If we call extensionConnection.send(...),\n          //   the extension would call the sanitizers.\n          // - If we call devtoolsExtension.send(...) (aka full state update),\n          //   the extension would NOT call the sanitizers, so we have to do it ourselves.\n\n        };\n\n        if (config.maxAge !== false\n        /* support === 0 */\n        ) {\n          extensionOptions.maxAge = config.maxAge;\n        }\n\n        return extensionOptions;\n      }\n    }, {\n      key: \"sendToReduxDevtools\",\n      value: function sendToReduxDevtools(send) {\n        try {\n          send();\n        } catch (err) {\n          console.warn('@ngrx/store-devtools: something went wrong inside the redux devtools', err);\n        }\n      }\n    }]);\n\n    return DevtoolsExtension;\n  }();\n\n  /** @nocollapse */\n\n  /** @nocollapse */\n  DevtoolsExtension.ɵfac = function DevtoolsExtension_Factory(t) {\n    return new (t || DevtoolsExtension)(i0.ɵɵinject(REDUX_DEVTOOLS_EXTENSION), i0.ɵɵinject(STORE_DEVTOOLS_CONFIG), i0.ɵɵinject(DevtoolsDispatcher));\n  };\n  /** @nocollapse */\n\n  /** @nocollapse */\n\n\n  DevtoolsExtension.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: DevtoolsExtension,\n    factory: DevtoolsExtension.ɵfac\n  });\n  return DevtoolsExtension;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nvar StoreDevtools = /*#__PURE__*/(function () {\n  var StoreDevtools = /*#__PURE__*/function () {\n    function StoreDevtools(dispatcher, actions$, reducers$, extension, scannedActions, errorHandler, initialState, config) {\n      var _this4 = this;\n\n      _classCallCheck(this, StoreDevtools);\n\n      var liftedInitialState = liftInitialState(initialState, config.monitor);\n      var liftReducer = liftReducerWith(initialState, liftedInitialState, errorHandler, config.monitor, config);\n      var liftedAction$ = merge(merge(actions$.asObservable().pipe(skip(1)), extension.actions$).pipe(map(liftAction)), dispatcher, extension.liftedActions$).pipe(observeOn(queueScheduler));\n      var liftedReducer$ = reducers$.pipe(map(liftReducer));\n      var liftedStateSubject = new ReplaySubject(1);\n      var liftedStateSubscription = liftedAction$.pipe(withLatestFrom(liftedReducer$), scan(function (_ref2, _ref3) {\n        var liftedState = _ref2.state;\n\n        var _ref4 = _slicedToArray(_ref3, 2),\n            action = _ref4[0],\n            reducer = _ref4[1];\n\n        var reducedLiftedState = reducer(liftedState, action); // On full state update\n        // If we have actions filters, we must filter completely our lifted state to be sync with the extension\n\n        if (action.type !== PERFORM_ACTION && shouldFilterActions(config)) {\n          reducedLiftedState = filterLiftedState(reducedLiftedState, config.predicate, config.actionsSafelist, config.actionsBlocklist);\n        } // Extension should be sent the sanitized lifted state\n\n\n        extension.notify(action, reducedLiftedState);\n        return {\n          state: reducedLiftedState,\n          action: action\n        };\n      }, {\n        state: liftedInitialState,\n        action: null\n      })).subscribe(function (_ref5) {\n        var state = _ref5.state,\n            action = _ref5.action;\n        liftedStateSubject.next(state);\n\n        if (action.type === PERFORM_ACTION) {\n          var unliftedAction = action.action;\n          scannedActions.next(unliftedAction);\n        }\n      });\n      var extensionStartSubscription = extension.start$.subscribe(function () {\n        _this4.refresh();\n      });\n      var liftedState$ = liftedStateSubject.asObservable();\n      var state$ = liftedState$.pipe(map(unliftState));\n      this.extensionStartSubscription = extensionStartSubscription;\n      this.stateSubscription = liftedStateSubscription;\n      this.dispatcher = dispatcher;\n      this.liftedState = liftedState$;\n      this.state = state$;\n    }\n\n    _createClass(StoreDevtools, [{\n      key: \"dispatch\",\n      value: function dispatch(action) {\n        this.dispatcher.next(action);\n      }\n    }, {\n      key: \"next\",\n      value: function next(action) {\n        this.dispatcher.next(action);\n      }\n    }, {\n      key: \"error\",\n      value: function error(_error) {}\n    }, {\n      key: \"complete\",\n      value: function complete() {}\n    }, {\n      key: \"performAction\",\n      value: function performAction(action) {\n        this.dispatch(new PerformAction(action, +Date.now()));\n      }\n    }, {\n      key: \"refresh\",\n      value: function refresh() {\n        this.dispatch(new Refresh());\n      }\n    }, {\n      key: \"reset\",\n      value: function reset() {\n        this.dispatch(new Reset(+Date.now()));\n      }\n    }, {\n      key: \"rollback\",\n      value: function rollback() {\n        this.dispatch(new Rollback(+Date.now()));\n      }\n    }, {\n      key: \"commit\",\n      value: function commit() {\n        this.dispatch(new Commit(+Date.now()));\n      }\n    }, {\n      key: \"sweep\",\n      value: function sweep() {\n        this.dispatch(new Sweep());\n      }\n    }, {\n      key: \"toggleAction\",\n      value: function toggleAction(id) {\n        this.dispatch(new ToggleAction(id));\n      }\n    }, {\n      key: \"jumpToAction\",\n      value: function jumpToAction(actionId) {\n        this.dispatch(new JumpToAction(actionId));\n      }\n    }, {\n      key: \"jumpToState\",\n      value: function jumpToState(index) {\n        this.dispatch(new JumpToState(index));\n      }\n    }, {\n      key: \"importState\",\n      value: function importState(nextLiftedState) {\n        this.dispatch(new ImportState(nextLiftedState));\n      }\n    }, {\n      key: \"lockChanges\",\n      value: function lockChanges(status) {\n        this.dispatch(new LockChanges(status));\n      }\n    }, {\n      key: \"pauseRecording\",\n      value: function pauseRecording(status) {\n        this.dispatch(new PauseRecording(status));\n      }\n    }]);\n\n    return StoreDevtools;\n  }();\n\n  /** @nocollapse */\n\n  /** @nocollapse */\n  StoreDevtools.ɵfac = function StoreDevtools_Factory(t) {\n    return new (t || StoreDevtools)(i0.ɵɵinject(DevtoolsDispatcher), i0.ɵɵinject(i2.ActionsSubject), i0.ɵɵinject(i2.ReducerObservable), i0.ɵɵinject(DevtoolsExtension), i0.ɵɵinject(i2.ScannedActionsSubject), i0.ɵɵinject(i0.ErrorHandler), i0.ɵɵinject(INITIAL_STATE), i0.ɵɵinject(STORE_DEVTOOLS_CONFIG));\n  };\n  /** @nocollapse */\n\n  /** @nocollapse */\n\n\n  StoreDevtools.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: StoreDevtools,\n    factory: StoreDevtools.ɵfac\n  });\n  return StoreDevtools;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nvar IS_EXTENSION_OR_MONITOR_PRESENT = new InjectionToken('@ngrx/store-devtools Is Devtools Extension or Monitor Present');\n\nfunction createIsExtensionOrMonitorPresent(extension, config) {\n  return Boolean(extension) || config.monitor !== noMonitor;\n}\n\nfunction createReduxDevtoolsExtension() {\n  var extensionKey = '__REDUX_DEVTOOLS_EXTENSION__';\n\n  if (typeof window === 'object' && typeof window[extensionKey] !== 'undefined') {\n    return window[extensionKey];\n  } else {\n    return null;\n  }\n}\n\nfunction createStateObservable(devtools) {\n  return devtools.state;\n}\n\nvar StoreDevtoolsModule = /*#__PURE__*/(function () {\n  var StoreDevtoolsModule = /*#__PURE__*/function () {\n    function StoreDevtoolsModule() {\n      _classCallCheck(this, StoreDevtoolsModule);\n    }\n\n    _createClass(StoreDevtoolsModule, null, [{\n      key: \"instrument\",\n      value: function instrument() {\n        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        return {\n          ngModule: StoreDevtoolsModule,\n          providers: [DevtoolsExtension, DevtoolsDispatcher, StoreDevtools, {\n            provide: INITIAL_OPTIONS,\n            useValue: options\n          }, {\n            provide: IS_EXTENSION_OR_MONITOR_PRESENT,\n            deps: [REDUX_DEVTOOLS_EXTENSION, STORE_DEVTOOLS_CONFIG],\n            useFactory: createIsExtensionOrMonitorPresent\n          }, {\n            provide: REDUX_DEVTOOLS_EXTENSION,\n            useFactory: createReduxDevtoolsExtension\n          }, {\n            provide: STORE_DEVTOOLS_CONFIG,\n            deps: [INITIAL_OPTIONS],\n            useFactory: createConfig\n          }, {\n            provide: StateObservable,\n            deps: [StoreDevtools],\n            useFactory: createStateObservable\n          }, {\n            provide: ReducerManagerDispatcher,\n            useExisting: DevtoolsDispatcher\n          }]\n        };\n      }\n    }]);\n\n    return StoreDevtoolsModule;\n  }();\n\n  /** @nocollapse */\n\n  /** @nocollapse */\n  StoreDevtoolsModule.ɵfac = function StoreDevtoolsModule_Factory(t) {\n    return new (t || StoreDevtoolsModule)();\n  };\n  /** @nocollapse */\n\n  /** @nocollapse */\n\n\n  StoreDevtoolsModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: StoreDevtoolsModule\n  });\n  /** @nocollapse */\n\n  /** @nocollapse */\n\n  StoreDevtoolsModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n  return StoreDevtoolsModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * DO NOT EDIT\n *\n * This file is automatically generated at build\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { INITIAL_OPTIONS, RECOMPUTE, StoreDevtools, StoreDevtoolsConfig, StoreDevtoolsModule };","map":null,"metadata":{},"sourceType":"module"}